## Лабораторная работа 1. Интерфейсы ввода-вывода общего назначения (GPIO)

### Цели работы

1. Получить базовые знания о принципах устройства стенда SDK-1.1M и программировании микроконтроллеров.  
   获得有关SDK-1.1M支架设计和微控制器编程原理的基本知识。
2. Изучить устройство интерфейсов ввода-вывода общего назначения (GPIO) в микроконтроллерах и приемы использования данных интерфейсов.  
   研究微控制器中通用输入/输出接口（GPIO）的设计以及如何使用这些接口。

### Задание

Разработать и реализовать драйверы управления светодиодными индикаторами и чтения состояния кнопки стенда SDK-1.1М (расположены на боковой панели стенда). Обработка нажатия кнопки в программе должна включать программную защиту от дребезга. Функции и другие компоненты драйверов должны быть универсальными, т. е. пригодными для использования в любом из вариантов задания и не должны содержать прикладной логики программы. Функции драйверов должны быть неблокирующими, то есть не должны содержать ожиданий события (например, нажатия кнопки). Также, в драйверах не должно быть пауз с активным ожиданием (функция HAL_Delay() и собственные варианты с аналогичной функциональностью).  
开发并实现用于控制 LED 指示灯和读取 SDK-1.1M 支架按钮（位于支架侧面板上）状态的驱动程序。程序中处理按钮按下操作必须包含软件防弹跳保护。驱动程序的功能和其他组件必须是通用的，即适合在任何版本的任务中使用，并且不得包含程序的应用逻辑。驱动程序函数必须是非阻塞的，即它们不能包含等待事件（例如，按下按钮）。此外，驱动程序不应因主动等待而暂停（HAL_Delay() 函数及其具有类似功能的变体）。

При необходимости параллельного выполнения разных процессов (например, опроса кнопки и ожидания перед переключением светодиодов) следует организовать псевдопараллельную работу процессов в стиле кооперативной многозадачности. Это возможно сделать без существенной потери точности соблюдения необходимых интервалов времени между действиями, поскольку действия выполняются очень быстро по сравнению с промежутками ожидания между ними. Каждый процесс (который может быть выражен всего в нескольких строках кода) должен использовать не активное ожидание (HAL_Delay()), а считывать текущее значение миллисекундного счетчика (HAL_GetTick()), проверяя, прошло ли необходимое количество времени для выполнения следующего действия. После проверки и (при необходимости) выполнения действия управление должно передаваться следующему процессу, чтобы он тоже мог провести такую проверку.  
如果需要并行执行不同的进程（例如，轮询按钮并在切换 LED 之前等待），则应以协作多任务处理的方式组织进程的伪并行操作。这可以在维持动作之间所需时间间隔的准确性方面没有显着损失的情况下完成，因为与动作之间的等待时间相比，动作执行得非常快。每个进程（可以用几行代码表达）不应该使用主动等待（HAL_Delay()），而是读取毫秒计数器的当前值（HAL_GetTick()），检查所需的时间是否已达到通过执行下一步操作。检查并（如有必要）执行操作后，控制必须转移到下一个流程，以便它也可以执行此类验证。

Контакты подключения кнопки и светодиодов должны быть настроены в режиме GPIO. Использование прерываний и дополнительных таймеров (кроме SysTick) не допускается.  
按钮和 LED 连接引脚必须配置为 GPIO 模式。不允许使用中断和附加定时器（SysTick 除外）。

Написать программу с использованием разработанных драйверов в соответствии с вариантом задания.  
根据任务选项，使用开发的驱动程序编写程序。

### Порядок выполнения работы

1. Изучить:  
   学习：
- устройство и инструкцию по эксплуатации стенда SDK-1.1M;  
  展台SDK-1.1M的设计和操作说明；
- основные характеристики микроконтроллера STM32 по листу данных (datasheet); документация выложена на сайте производителя [34] (например, см. документацию микроконтроллера STM32F427VIT6 [41], обозначение документа - DS9405 [7]);  
  据数据表的 STM32 微控制器的主要特性；文档发布在制造商的网站上 [34]（例如，请参阅 STM32F427VIT6 微控制器的文档 [41]，文档名称 - DS9405 [7]）；
- разделы учебного пособия:  
  手册各部分：
  - 1.1. Сигналы сброса и синхронизации;  
    复位和同步信号； 
  - 1.2. Интерфейс ввода-вывода общего назначения (GPIO);  
    通用输入/输出接口（GPIO）；
- электрическую принципиальную схему стенда в части управления светодиодами и кнопкой, используемыми в данной работе;  
  控制本作品中使用的 LED 和按钮的支架电路图；
- раздел «General purpose I/O (GPIO)» из справочного руководства (reference manual) по микроконтроллерам линейки STM32F4 (обозначение документа - RM0090 [4]), знать устройство портов ввода-вывода, режимы их работы и способы настройки.  
  STM32F4 系列微控制器参考手册（文档名称 - RM0090 [4]）中的“通用 I/O (GPIO)”部分，了解 I/O 端口的设计、其操作模式和配置方法。
2. Создать и настроить пустой проект программы для SDK-1.1M.  
   为SDK-1.1M 创建并配置一个空程序项目。
3. Настроить тактовые частоты.  
   设置时钟频率。
4. Настроить сигналы GPIO, необходимые для выполнения задания.  
   配置完成作业所需的 GPIO 信号。
5. Изучить:  
   学习：
- состав стандартного драйвера GPIO из библиотеки HAL (файлы stm32f4xx_hal_gpio.c/.h в проекте), знать основные определения и функции, принцип работы драйвера. Справочная информация находится в комментариях в файле драйвера в документации (обозначение документа - UM1725 Description of STM32F4 HAL and low-layer drivers [42]) с сайта производителя;  
  由HAL库（项目中的文件stm32f4xx_hal_gpio.c/.h）组成标准GPIO驱动程序，了解驱动程序的基本定义和功能、工作原理。帮助信息位于制造商网站文档中驱动程序文件的注释中（文档名称 - UM1725 STM32F4 HAL 和低层驱动程序说明 [42]）；
- содержимое инициализационного кода в созданных генератором файлах gpio.c/.h.  
  生成器创建的 gpio.c/.h 文件中初始化代码的内容。
6. Разработать драйверы управления светодиодами и чтения состояния кнопки.  
   开发用于控制 LED 和读取按钮状态的驱动程序。
7. Разработать программу согласно варианту задания и провести ее тестирование.  
   根据作业选项开发程序并测试。
8. Модифицировать программу: отключить в графическом конфигураторе настройку портов GPIO. Разработать собственные функции для инициализации и использования портов GPIO (можно с использованием объявленных в стандартной библиотеке структур и констант). Заменить в программе использование библиотечных функций работы с GPIO на вызов собственных реализаций.  
   修改程序：在图形配置器中禁用GPIO端口的配置。开发您自己的函数来初始化和使用 GPIO 端口（您可以使用标准库中声明的结构体和常量）。通过调用您自己的实现来替换在程序中使用库函数来处理 GPIO。

### Вариант 2

Реализовать простой имитатор гирлянды с переключением режимов. Должно быть реализовано не менее четырех последовательностей переключения светодиодов, обязательно с разной частотой мигания (должны быть визуально отличимыми). В каждом режиме задействуется не менее двух светодиодов. По нажатию кнопки происходит циклическое переключение режимов. При повторном входе в какой-либо режим анимация на светодиодах должна запускаться с того места, на котором в прошлый раз была прервана переключением на следующий режим. Удерживание зажатой кнопки не должно приводить к «повисанию» анимации.  
实现一个带有模式切换的简单花环模拟器。必须实施至少四个 LED 开关序列，并且始终具有不同的闪烁频率（必须在视觉上可区分）。每种模式至少使用两个 LED。通过按下按钮，模式会循环切换。当您重新进入任何模式时，LED 上的动画应从上次切换到下一个模式而中断的点开始。按住按钮不应导致动画冻结。

## Лабораторная работа 2. Последовательный интерфейс UART

### Цели работы

1. Изучить протокол передачи данных по интерфейсу UART.  
   研究UART接口的数据传输协议。
2. Получить базовые знания об организации системы прерываний в микроконтроллерах на примере микроконтроллера STM32.  
   以 STM32 微控制器为例，了解微控制器中中断系统组织的基本知识。
3. Изучить устройство и принципы работы контроллера интерфейса UART, получить навыки организации обмена данными по UART в режимах опроса и прерываний.  
   研究UART接口控制器的设计和工作原理，获得在轮询和中断模式下通过UART组织数据交换的技能。

Задание

Разработать и реализовать два варианта драйверов UART для стенда SDK-1.1M: с использованием и без использования прерываний. Драйверы, использующие прерывания, должны обеспечивать работу в «неблокирующем» режиме (возврат из функции происходит сразу же, без ожидания окончания приема/отправки), а также буферизацию данных для исключения случайной потери данных. В драйвере, не использующем прерывания, функция приема данных также должна быть «неблокирующей», то есть она не должна зависать до приема данных (которые могут никогда не поступить). При использовании режима «без прерываний» прерывания от соответствующего блока UART должны быть запрещены.  
为 SDK-1.1M 支架开发和实现两个版本的 UART 驱动程序：带中断和不带中断。使用中断的驱动程序必须确保以“非阻塞”模式运行（函数立即返回，无需等待接收/发送结束），以及数据缓冲以防止意外数据丢失。在不使用中断的驱动程序中，数据接收函数也必须是“非阻塞”的，即在接收数据之前不能挂起（数据可能永远不会到达）。当使用“无中断”模式时，必须禁用来自相应 UART 模块的中断。

Написать с использованием разработанных драйверов программу, которая выполняет определенную вариантом задачу. Для всех вариантов должно быть реализовано два режима работы программы: с использованием и без использования прерываний. Каждый принимаемый стендом символ должен отсылаться обратно, чтобы он был выведен в консоли (так называемое «эхо»). Каждое новое сообщение от стенда должно выводиться с новой строки. Если вариант предусматривает работу с командами, то на каждую команду должен выводиться ответ, определенный в задании или «ОК», если ответ не требуется. Если введена команда, которая не поддерживается, должно быть выведено сообщение об этом.  
使用开发的驱动程序编写执行特定任务的程序。对于所有选项，必须实现两种程序操作模式：带中断和不带中断。支架接收到的每个字符都必须被发送回，以便在控制台中显示（所谓的“回显”）。展台上的每条新消息都应显示在新行上。如果该选项涉及使用命令，则对于每个命令，应显示任务中定义的响应，如果不需要响应，则应显示“确定”。如果输入的命令不受支持，则应显示一条消息来指示这一点。

Скорость работы интерфейса UART должна соответствовать указанной в варианте задания  
UART接口的速度必须与作业选项中指定的速度相对应

Порядок выполнения работы  
工单

1. Изучить: 学习：
   - разделы учебного пособия: 教材章节：
     - 1.3. Прерывания; 1.3 中断
     - 1.4. Последовательный интерфейс UART; 1.4 串行接口 UART
   - электрическую принципиальную схему стенда в части назначения сигналов отладочного интерфейса UART;  
     有关 UART 调试接口信号分配的支架电路图； 
   - раздел справочного руководства RM0090: «Universal synchronous asynchronous receiver transmitter (USART)», знать устройство контроллера USART, режимы его работы и способы настройки;  
     参考手册RM0090部分：“通用同步异步接收发送器（USART）”，了解USART控制器的设计、其工作模式和配置方法； 
   - раздел справочного руководства PM0214 (programming manual) [43] о контроллере прерываний: «Nested vectored interrupt controller (NVIC)», знать принципы организации системы прерываний в микроконтроллере STM32F4 и приемы ее использования;  
     参考手册PM0214（编程手册）[43]中关于中断控制器的部分：“嵌套向量中断控制器（NVIC）”，了解STM32F4微控制器中组织中断系统的原理以及如何使用它； 
   - состав стандартного драйвера USART из библиотеки HAL и содержимое создаваемых генератором файлов usart.c/.h.  
     HAL 库中的标准 USART 驱动程序的组成以及生成器创建的 usart.c/.h 文件的内容。 
2. Подготовить шаблон проекта для STM32CubeIDE, настроить тактовые частоты.  
   准备STM32CubeIDE的工程模板，设置时钟频率。
3. Задать настройки контроллера UART, настроить входы и выходы микроконтроллера.  
   设置UART控制器设置，配置微控制器输入和输出。
4. Разработать драйверы UART для работы в режимах опроса и прерывания. Драйвер, работающий в режиме прерывания, должен поддерживать буферизацию данных и работу в «неблокирующем режиме».  
   开发UART驱动程序以轮询和中断模式运行。在中断模式下运行的驱动程序必须支持数据缓冲并在“非阻塞模式”下运行。
5. Разработать программу согласно варианту задания и провести ее тестирование.  
   根据作业选项开发程序并测试。

### Варианты заданий

Вариант 2

Доработать программу «гирлянда», реализовав возможность добавления четырёх новых последовательностей миганий светодиодов с индивидуальной настройкой периода переключения состояний для каждой последовательности. Каждая вводимая последовательность должна иметь от двух до восьми состояний. В каждый момент времени может гореть только один светодиод (или не гореть ни один). Смена отображаемой в данный момент последовательности должна осуществляться нажатием кнопки или командой, посылаемой через UART.  
通过实现添加四个新的 LED 闪烁序列以及单独调整每个序列的状态切换周期的功能，改进了“花环”程序。每个输入序列必须具有二到八个状态。一次只能点亮一个 LED（或根本不点亮）。更改当前显示的序列必须通过按下按钮或通过 UART 发送的命令来完成。

Должны обрабатываться следующие команды, посылаемые через UART:  
必须处理通过 UART 发送的以下命令：
- new xx… – ввести новую последовательность, где «x» – это одна из букв g, r, y, n («g» соответствует включению зелёного светодиода, «r» – красного, «y» – жёлтого, «n» означает, что ни один светодиод не горит); количество вводимых значений «x» может быть от двух до восьми, ввод завершается либо по нажатию Enter, либо после ввода восьми значений; после окончания ввода последовательности миганий стенд должен послать сообщение произвольного содержания, приглашающее ввести период переключения светодиодов (должны предусматриваться минимум три градации – например, быстро (200 мс), средне (500 мс) и медленно (1000 мс)); ввод периода переключения заканчивается по нажатию Enter; новой последовательности присваивается очередной свободный номер от 5 до 8; если уже есть 8 последовательностей, то переопределяется последовательность 5 и т. д.; номер новой сохраненной последовательности выводится в UART;  
  new xx... – 输入新序列，其中“x”是字母 g、r、y、n 之一（“g”对应于打开绿色 LED，“r”- 红色，“y”-黄色，“n”表示没有 LED 点亮）；输入值的个数“x”可以是2到8个，按回车键或输入8个值后即可完成输入；完成闪烁序列的输入后，展台必须发送任意内容的消息，邀请您进入 LED 切换周期（必须提供至少三个等级 - 例如，快速（200 ms）、中（500 ms）和慢（1000 毫秒））；输入切换周期按回车结束；新序列被分配从 5 到 8 的下一个空闲编号；如果已经有8个序列，则重新定义序列5，依此类推；新保存的序列号显示在UART中；
- set х – сделать активной последовательность мерцаний х, где х – порядковый номер;  
  设置 x – 激活闪烁序列 x，其中 x 是序列号；
- set interrupts on или set interrupts off – включить или выключить прерывания.  
  设置中断打开或设置中断关闭 - 启用或禁用中断。

Скорость обмена данными по UART – 38400 бит/с.  
通过 UART 的数据交换率为 38400 bps。