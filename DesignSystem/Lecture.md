## 1. Основные механизмы встраиваемых систем на примере стенда SDK-1.1M <br> 嵌入式系统的基本机制：以SDK-1.1M为例

В качестве примера в данном разделе будут рассматриваться стенды SDK-1.1M на базе
микроконтроллеров линейки STM32F407/STM32F427, имеющие процессорное ядро с
архитектурой ARM Cortex-M4.  
本节以基于STM32F407/STM32F427微控制器的SDK-1.1M设备为例，这些微控制器具有采用ARM Cortex-M4架构的处理器核心。

Устройство SDK-1.1M описано в главе 3.  
设备SDK-1.1M的描述详见第3章。

### 1.1. Сигналы сброса и синхронизации <br> 复位和同步信号

Общие сведения  
通用信息

Сигнал сброса (reset) возвращает микроконтроллер в начальное состояние. При этом
микроконтроллер начинает исполнять программу с начала. В стенде SDK-1.1M сброс можно выполнить, нажав на кнопку «RESET» на лицевой панели (рис. 37).  
复位信号（reset）将微控制器恢复到初始状态，此时微控制器会从程序的起点开始执行。在SDK-1.1M中，可以通过按下面板上的“RESET”按钮来完成复位（如图37所示）。

Для работы любого микроконтроллера необходимы синхросигналы, которые задают тактовые частоты работы процессорного ядра и других аппаратных блоков. В микроконтроллерах обычно предусмотрены несколько источников синхросигналов (внешних и внутренних, имеющих разную частоту работы) и широкие возможности по настройке их частот.  
微控制器的运行需要同步信号，这些信号设定了处理器核心及其他硬件模块的时钟频率。通常，微控制器支持多种同步信号源（内部和外部），并提供灵活的频率设置选项

Пример настройки синхросигналов в STM32  
STM32的同步信号配置示例

Включить использование внешнего скоростного кварцевого резонатора (System Core → RCC→ High Speed Clock (HSE): выбрать «Crystal/Ceramic Resonator»).  
启用外部高速晶体振荡器：在System Core → RCC → High Speed Clock (HSE)中选择“Crystal/Ceramic Resonator”。

Настроить дерево синхронизации (режим конфигурирования микроконтроллера, вкладка Clock Configuration), на примере STM32F427VI (рис. 2):  
配置同步树（Clock Configuration模式），以STM32F427VI为例（如图2所示）：

- ввести частоту внешнего скоростного кварцевого резонатора (HSE Input frequency): 25 МГц (указана на электрической принципиальной схеме стенда);  
  输入外部高速晶体振荡器的频率（HSE Input frequency）：25MHz（参见电路原理图）。
- выбрать HSE как источник синхросигнала для основного блока подстройки частоты (Main PLL);  
  选择HSE作为主频率调整模块（Main PLL）的信号源。
- выбрать PLLCLK как источник синхросигнала SYSCLK;  
  选择PLLCLK作为SYSCLK的信号源。
- ввести желаемую частоту HCLK (основная частота микроконтроллера), равную максимальной (указана под данным полем), для STM32F427VI – 180 МГц.  
  设置微控制器的主频率HCLK为最高值（STM32F427VI的最高频率为180MHz）。

После этого STM32CubeIDE автоматически рассчитает настройки дерева синхронизации для получения нужных частот с учетом всех ограничений.  
配置完成后，STM32CubeIDE会自动计算同步树的设置，确保满足频率约束。

### 1.2. Интерфейс ввода-вывода общего назначения (GPIO)

Общие сведения о GPIO  
有关 GPIO 的一般信息

Интерфейс ввода-вывода общего назначения (general-purpose input/output, GPIO) – базовый интерфейс взаимодействия компьютерной системы с внешним миром. С его помощью к контактам (ножкам, «пинам») микроконтроллера чаще всего подключаются такие внешние элементы как светодиоды, кнопки, переключатели, осуществляется управление периферийными устройствами и т. д.  
通用输入/输出接口（GPIO）是计算机系统与外界之间的基本接口。在它的帮助下，LED、按钮、开关等外部元件通常连接到微控制器的触点（引脚、“引脚”）、控制外围设备等。

Контакты микроконтроллера внутри подключаются к портам ввода-вывода. Пример организации единичного порта ввода-вывода приведен на рис. 3. Такие порты GPIO обычно объединяются в группы по 8, 16 или 32 порта с общими регистрами управления. Одни и те же порты могут выступать в роли входа или выхода в зависимости от настроек. По умолчанию обычно включен режим входа, чтобы исключить влияние порта на другие части схемы. Для работы в качестве выхода необходимо настроить соответствующий порт на выход при помощи управляющих регистров (описаны в документации микроконтроллера). Каждый контакт настраивается индивидуально – в одной группе портов входы и выходы могут чередоваться в любых комбинациях.  
内部的微控制器引脚连接到I/O端口。图 1 显示了组织单个 I/O 端口的示例。 3. 此类 GPIO 端口通常组合成 8、16 或 32 个端口组，并具有公共控制寄存器。根据设置，相同的端口可以用作输入或输出。默认情况下，通常启用输入模式以防止端口干扰电路的其他部分。要作为输出运行，必须使用控制寄存器（在微控制器文档中描述）将相应的端口配置为输出。每个触点均单独配置 - 在一组端口中，输入和输出可以以任意组合交替。

![](./pics/lecture1.2-1.png)

Рисунок 2 – Настройки дерева синхронизации микроконтроллера STM32F427VI  
图 2 – STM32F427VI 微控制器同步树设置

Также порты ввода-вывода позволяют в качестве «альтернативной функции» подключать к контактам микроконтроллера различные аппаратные блоки – контроллеры интерфейсов ввода вывода, генераторы сигналов и т. п.  
此外，I/O 端口作为“替代功能”，允许将各种硬件单元连接到微控制器触点 - 输入/输出接口控制器、信号发生器等。

В STM32 единичные порты GPIO объединяются в групповые порты по 16 штук, которые называются GPIOA, GPIOB и т. д. Соответствующие им контакты микроконтроллера называются PA1, PA2, …, PB1, PB2, … и т. д.  
在STM32中，单个GPIO端口被组合成16个组端口，称为GPIOA、GPIOB等。对应的单片机引脚称为PA1、PA2、...、PB1、PB2、...等。

В стенде SDK-1.1M с процессорным модулем на базе STM32 на боковой панели имеется одна кнопка, подключённая к контакту PC15, и два управляемых светодиода: зеленый, подключенный к PD13, и двухцветный красный/желтый, подключенный к контактам PD14 и PD15 (рис. 4, 36).  
在侧面板上带有基于 STM32 的处理器模块的 SDK-1.1M 支架中，有一个按钮连接到引脚 PC15，以及两个可控 LED：绿色，连接到 PD13，以及两色红/黄，连接到引脚 PD14和 PD15（图 4、36）。

Пример работы с GPIO в STM32  
在 STM32 中使用 GPIO 的示例

Произведем настройку контактов микроконтроллера в SDK-1.1M. В STM32CubeIDE в режиме конфигурирования микроконтроллера на вкладке Pinouts & Configuration необходимо перевести контакты PD13 – PD15 в режим GPIO_Output (рис. 5).  
让我们在 SDK-1.1M 中配置微控制器触点。在STM32CubeIDE中，在Pinouts & Configuration选项卡上的微控制器配置模式下，您需要将引脚PD13 – PD15切换到GPIO_Output模式（图5）。

После сохранения конфигурации микроконтроллера STM32CubeIDE сгенерирует и добавит в проект код для инициализации микроконтроллера в соответствии с заданными настройками.  
保存微控制器配置后，STM32CubeIDE将生成代码并将其添加到项目中，以按照指定的设置初始化微控制器。

ВНИМАНИЕ: при повторной генерации файлов из них удаляется весь код, добавленный пользователем, кроме кода, который написан между парами комментариев вида /* USER CODE BEGIN ... */, /* USER CODE END ... */.  
注意：重新生成文件时，用户添加的所有代码都将从文件中删除，除了在 /* USER CODE BEGIN ... */, /* USER CODE END ... 形式的注释对之间编写的代码之外。 */。

Для работы с GPIO, как и с другой периферией, на STM32 рекомендуется использовать библиотеку HAL (Hardware Abstraction Layer), поддержка которой встроена в IDE. При генерации проекта STM32CubeIDE добавляет в код функцию MX_GPIO_Init(), инициализирующую порты GPIO в соответствии с настройками:  
要在 STM32 上使用 GPIO 以及其他外设，建议使用 HAL（硬件抽象层）库，IDE 中内置了对其的支持。在生成工程时，STM32CubeIDE在代码中添加MX_GPIO_Init()函数，该函数根据设置初始化GPIO端口：

```
static void MX_GPIO_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    __HAL_RCC_GPIOH_CLK_ENABLE();
    __HAL_RCC_GPIOD_CLK_ENABLE();
    __HAL_RCC_GPIOA_CLK_ENABLE();
    __HAL_RCC_GPIOB_CLK_ENABLE();
    HAL_GPIO_WritePin(GPIOD,GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET);
    GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
}
```

![](./pics/lecture1.2-2.png)

Рисунок 3 – Организация единичного порта ввода-вывода в STM32 [4]

![](./pics/lecture1.2-3.png)

Рисунок 4 – Подключение кнопки и управляемых светодиодов на принципиальной электрической схеме SDK-1.1M

![](./pics/lecture1.2-4.png)

Рисунок 5 – Окно настройки портов GPIO

Для установки значения на выход и чтения входа используются стандартные функции из библиотеки HAL:  
要设置输出值并读取输入，使用 HAL 库中的标准函数：

```
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState);
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
```

Параметры:  
参数：

- *GPIOx – выбор порта; указатель на контекст драйвера конкретного порта; буква «x» соответствует имени порта; для управления светодиодами необходимо использовать порт GPIOD;  
  *GPIOx – 端口选择；指向特定端口驱动程序上下文的指针；字母“x”对应端口名称；要控制 LED，您必须使用 GPIOD 端口；
- GPIO_Pin – номер контакта, например, GPIO_PIN_13;  
  GPIO_Pin – 引脚序号，例如 GPIO_PIN_13；
- PinState – состояние контакта: GPIO_PIN_SET («1») или GPIO_PIN_RESET («0»).  
  PinState – 引脚状态：GPIO_PIN_SET（“1”）或 GPIO_PIN_RESET（“0”）。

Для выполнения задержки на заданное количество миллисекунд (активное ожидание), получения текущего значения миллисекундного счетчика используются следующие функции:  
要延迟指定的毫秒数（主动等待），获取毫秒计数器的当前值，使用以下函数：

```
void HAL_Delay(uint32_t Delay);
uint32_t HAL_GetTick(void);
```

Пример кода, который переключает состояние зеленого светодиода каждые 500 мс:  
每 500 毫秒切换一次绿色 LED 的示例代码：

```
while (1)
{
    HAL_GPIO_WritePin(GPIOD, GPIO_PIN_13, GPIO_PIN_RESET);
    HAL_Delay(500);
    HAL_GPIO_WritePin(GPIOD, GPIO_PIN_13, GPIO_PIN_SET);
    HAL_Delay(500);
}
```

Дребезг механических контактов  
机械接触颤振

Механические контакты подвержены явлению дребезга. Его суть в том, что при замыкании контакта нажатием на кнопку напряжение устанавливается не сразу, а в течение некоторого времени (десятки миллисекунд) «скачет», пока контакт надежно не замкнется. После того, как кнопка будет отпущена, напряжение также «скачет», пока не установится на нужном уровне (рис. 6). Такое многократное замыкание/размыкание контактов вызвано тем, что контакты пружинят, обгорают и т. п.  
机械接触会出现颤振现象。其本质是，当按下按钮闭合触点时，电压并不是立即建立，而是“跳跃”一段时间（几十毫秒），直到触点可靠闭合。释放按钮后，电压也会“跳跃”，直到达到所需水平（图 6）。这种触点的反复闭合/断开是由触点弹起、烧毁等引起的。

![](./pics/lecture1.2-5.png)

Рисунок 6 – Пример временной диаграммы напряжения цепи при нажатии кнопки с дребезгом контактов  
图 6 – 按下带有触点弹跳的按钮时电路电压的时间图示例

Поскольку процессор реагирует на события очень быстро, то он может воспринять эти скачки напряжения за несколько нажатий. Решить данную проблему можно как аппаратно с помощью RS-триггера или триггера Шмитта, так и программно посредством отслеживания временных интервалов между замыканием и размыканием контактов.  
由于处理器对事件的反应非常快，因此只需点击几下就可以感知到这些电涌。这个问题可以通过使用 RS 触发器或施密特触发器的硬件来解决，也可以通过监视闭合和打开触点之间的时间间隔来通过软件来解决。

Например, можно использовать небольшую задержку перед следующим опросом кнопки после фиксации замыкания. Задержка подбирается такой, чтобы дребезг успел прекратиться к ее окончанию. Если второй опроса также показал, что контакт замкнут, можно считать, что кнопка нажата.  
例如，您可以在提交短路后下次轮询按钮之前使用短暂的延迟。选择延迟以使颤振有时间在延迟结束时停止。如果第二次轮询也显示联系人已关闭，我们可以假设按钮已按下。

Использование сигнала от кнопки как внешнего прерывания из-за дребезга требует реализации специальных механизмов ожидания и использования таймеров, поэтому является более сложным. Еще одним вариантом является постоянный периодический опрос состояния сигнала кнопки по прерыванию от таймера (будет рассмотрено в следующих разделах).  
使用按钮信号作为外部反弹中断需要实现特殊的等待机制并使用定时器，因此比较复杂。另一种选择是通过定时器中断持续定期轮询按钮信号状态（将在以下部分中讨论）。

В SDK-1.1M аппаратная защита от дребезга не реализована, поэтому необходимо предусматривать один из вариантов программной защиты.  
在SDK-1.1M中，没有实现硬件反弹保护，因此有必要提供软件保护选项之一。

### 1.3. Прерывания

Общие сведения о прерываниях  
了解中断

Прерывание – процесс переключения процессорного ядра с одной программы на другую по внешнему сигналу с сохранением информации для последующего возобновления прерванной программы.  
中断是通过外部信号将处理器核心从一个程序切换到另一个程序的过程，为后续恢复被中断的程序保存信息。

Основная роль механизма прерываний в процессорном ядре – реализация асинхронного режима работы программ и распараллеливания работы отдельных устройств вычислительного комплекса. Механизм прерываний реализуется аппаратными и программными средствами: контроллером прерываний и обработчиками прерываний.  
处理器核心中中断机制的主要作用是实现程序的异步运行方式以及并行化计算复合体各个设备的运行。中断机制通过硬件和软件实现：中断控制器和中断处理程序。

Каждое событие, требующее прерывания, сопровождается сигналом («запросом») прерывания, оповещающим об этом вычислительную машину.  
每个需要中断的事件都伴随着一个中断信号（“请求”），通知计算机这一点。

Обработка прерывания выполняется в три основных этапа:  
中断处理分三个主要阶段进行：

1. Прекращение выполнения текущей программы. Для корректного возврата к выполнению программы после обработки прерывания необходимо предварительно сохранить в специальном стеке контекст программы – содержимое регистров микроконтроллера (счетчик команд и др.).  
   终止当前程序。为了在处理中断后正确返回程序执行，必须首先将程序上下文保存在特殊的堆栈中 - 微控制器寄存器（程序计数器等）的内容。

2. Переход к выполнению программы обработчика. Определяется приоритетный источник прерывания и соответствующий вектор прерывания. Адрес вектора прерывания записывается в регистр счетчика команд. После этого осуществляется переход к программе-обработчику прерывания и ее выполнение.  
   转移到处理程序的执行。确定优先级中断源和对应的中断向量。中断向量地址被写入程序计数器寄存器。此后，转移到中断处理程序并执行。
3. Возврат управления прерванной программе. Для корректного возврата управления необходимо восстановить контекст программы из стека. Последней командой программы обработки прерывания должна быть команда, которая осуществляет возврат в основную программу и восстановление предварительно сохраненного контекста.  
   将控制权返回给被中断的程序。为了正确地返回控制权，需要从堆栈中恢复程序上下文。中断例程的最后一条指令必须是返回主程序并恢复先前保存的上下文的指令。

Обработчик прерывания предназначен для быстрого реагирования на события, и в программе может быть определено множество обработчиков. В связи с этим время исполнения каждого из них должно быть максимально коротким, чтобы не задерживать обработку других прерываний. Крайне нежелательно выполнение в обработчике прерывания таких долгих операций, как обмен данными по опросу (с ожиданием конца обмена), задержка на определенное время и пр. Такие операции необходимо перекладывать на основной поток управления (главный цикл), который может быть прерван в любой момент.  
中断处理程序旨在快速响应事件，并且可以在程序中定义许多处理程序。对此，它们各自的执行时间应尽可能短，以免耽误其他中断的处理。在中断处理程序中进行诸如轮询数据交换（等待交换结束）、延迟一定时间等长时间操作是极其不可取的。此类操作必须转移到主控制线程（主循环）中，可以随时中断。

Вектор прерывания – вектор начального состояния обработчика прерывания. Содержит всю необходимую информацию для перехода к обработчику, в том числе его начальный адрес. Каждому типу прерываний соответствует свой вектор прерывания, который инициализирует выполнение соответствующего обработчика. Обычно векторы прерывания хранятся в специально выделенных фиксированных ячейках памяти с короткими адресами, представляющих собой таблицу векторов прерываний. Для перехода к соответствующей прерывающей программе процессор должен располагать вектором прерывания и адресом этого вектора. По этому адресу, как правило, находится команда безусловного перехода к подпрограмме обработки прерывания.  
中断向量是中断处理程序的初始状态的向量。包含导航到处理程序的所有必要信息，包括其起始地址。每个中断类型都有自己的中断向量，该向量启动相应处理程序的执行。通常，中断向量存储在专门分配的具有短地址的固定存储器位置中，其表示中断向量表。为了跳转到适当的中断程序，处理器必须有一个中断向量和这个向量的地址。通常，在该地址处有一个到中断处理子例程的无条件跳转命令。

Приоритеты прерываний – это механизм, позволяющий установить определенный порядок обработки запросов прерываний. При наличии нескольких запросов прерываний, поступивших одновременно, приоритет прерывания будет определять, какой из поступивших запросов будет обработан в первую очередь.  
中断优先级是一种允许您设置处理中断请求的特定顺序的机制。如果有多个中断请求同时到达，则中断的优先级将决定首先处理哪个传入请求。

Вложенные прерывания – механизм, позволяющий осуществлять обработку поступившего запроса прерывания во время обработки другого прерывания. Если во время обработки прерывания поступает запрос на прерывание с более высоким уровнем приоритета, управление передается обработчику прерывания более высокого приоритета, при этом работа обработчика прерывания с более низким уровнем приоритета приостанавливается. Максимальное число обработчиков, которые могут приостанавливать друг друга, называется глубиной прерываний.  
嵌套中断是一种允许您在处理另一个中断的同时处理传入中断请求的机制。如果在处理中断时接收到较高优先级的中断请求，则控制权将转移到较高优先级的中断处理程序，而较低优先级的中断处理程序将被挂起。可以互相挂起的处理程序的最大数量称为中断深度。

Более подробная информация об устройстве подсистемы прерываний и применении прерываний доступна в пособии [5], раздел 1.2.4 и пособии [6], раздел 2.3.  
有关中断子系统设计和中断使用的更多详细信息，请参阅手册 [5] 第 1.2.4 节和手册 [6] 第 2.3 节。

Критические секции  
关键部分

### 4.1. Подключение стенда к компьютеру

Стенд SDK-1.1M подключается к персональному компьютеру через разъем «DBG USB» (см. рис. 36) кабелем с разъемом USB 2.0 Micro-B (входит в комплект поставки стенда). После подключения на лицевой панели стенда должен загореться светодиодный индикатор «VTGT».

Через разъем «DBG USB» обеспечивается электропитание стенда, а также подключение компьютера к встроенному программатору-отладчику стенда. Программатор-отладчик предназначен для загрузки программ в стенд и их отладки. Он обеспечивает подключение к вычислителю процессорного модуля по интерфейсам JTAG и UART (в режиме виртуального COM-порта). Через JTAG происходит взаимодействие с отладочной инфраструктурой вычислителя, а UART можно использовать для организации пользовательского отладочного ввода-вывода.

Для выключения стенда необходимо отключить его от компьютера.

ВНИМАНИЕ: когда стенд не используется, рекомендуется отключать USB-кабель от стенда во избежание случайного механического повреждения USB-разъема.

4.2. Установка драйверов встроенного программатора-отладчика 

Встроенный программатор-отладчик SDK-1.1M построен с применением универсальной микросхемы-конвертера интерфейса USB фирмы FTDI [31]. Подключение с инструментального компьютера к программатору-отладчику выполняется с использованием специального драйвера USB и открытого фреймворка OpenOCD.

При первом использовании SDK-1.1M требуется установить на компьютер необходимые драйверы, как указано ниже.

Процедура установки драйверов для macOS
Установка драйверов для macOS не требуется.

4.3. Инструментальные средства разработки для микроконтроллеров STM32

Для разработки и отладки программ для микроконтроллеров семейства STM32 рекомендуется использовать среду разработки STM32CubeIDE [21], которая доступна для скачивания с сайта производителя [34].

STM32CubeIDE – это интегрированная среда разработки (IDE), которая включает:
– графический конфигуратор STM32CubeMX (Micro eXplorer; также доступен в виде отдельного приложения), позволяющий выбирать желаемую конфигурацию блоков микроконтроллера STM32 и генерировать шаблоны проектов с необходимым кодом инициализации на языке C или C++ посредством наглядного пошагового процесса (рис. 39);

– поддержку стандартной библиотеки драйверов (HAL) и дополнительных программных модулей (middleware);
– классические средства редактирования кода, сборки и отладки проектов.