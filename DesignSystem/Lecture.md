## 1. Основные механизмы встраиваемых систем на примере стенда SDK-1.1M <br> 嵌入式系统的基本机制：以SDK-1.1M为例

В качестве примера в данном разделе будут рассматриваться стенды SDK-1.1M на базе
микроконтроллеров линейки STM32F407/STM32F427, имеющие процессорное ядро с
архитектурой ARM Cortex-M4.  
本节以基于STM32F407/STM32F427微控制器的SDK-1.1M设备为例，这些微控制器具有采用ARM Cortex-M4架构的处理器核心。

Устройство SDK-1.1M описано в главе 3.  
设备SDK-1.1M的描述详见第3章。

### 1.1. Сигналы сброса и синхронизации <br> 复位和同步信号

Общие сведения  
通用信息

Сигнал сброса (reset) возвращает микроконтроллер в начальное состояние. При этом
микроконтроллер начинает исполнять программу с начала. В стенде SDK-1.1M сброс можно выполнить, нажав на кнопку «RESET» на лицевой панели (рис. 37).  
复位信号（reset）将微控制器恢复到初始状态，此时微控制器会从程序的起点开始执行。在SDK-1.1M中，可以通过按下面板上的“RESET”按钮来完成复位（如图37所示）。

Для работы любого микроконтроллера необходимы синхросигналы, которые задают тактовые частоты работы процессорного ядра и других аппаратных блоков. В микроконтроллерах обычно предусмотрены несколько источников синхросигналов (внешних и внутренних, имеющих разную частоту работы) и широкие возможности по настройке их частот.  
微控制器的运行需要同步信号，这些信号设定了处理器核心及其他硬件模块的时钟频率。通常，微控制器支持多种同步信号源（内部和外部），并提供灵活的频率设置选项

Пример настройки синхросигналов в STM32  
STM32的同步信号配置示例

Включить использование внешнего скоростного кварцевого резонатора (System Core → RCC→ High Speed Clock (HSE): выбрать «Crystal/Ceramic Resonator»).  
启用外部高速晶体振荡器：在System Core → RCC → High Speed Clock (HSE)中选择“Crystal/Ceramic Resonator”。

Настроить дерево синхронизации (режим конфигурирования микроконтроллера, вкладка Clock Configuration), на примере STM32F427VI (рис. 2):  
配置同步树（Clock Configuration模式），以STM32F427VI为例（如图2所示）：

- ввести частоту внешнего скоростного кварцевого резонатора (HSE Input frequency): 25 МГц (указана на электрической принципиальной схеме стенда);  
  输入外部高速晶体振荡器的频率（HSE Input frequency）：25MHz（参见电路原理图）。
- выбрать HSE как источник синхросигнала для основного блока подстройки частоты (Main PLL);  
  选择HSE作为主频率调整模块（Main PLL）的信号源。
- выбрать PLLCLK как источник синхросигнала SYSCLK;  
  选择PLLCLK作为SYSCLK的信号源。
- ввести желаемую частоту HCLK (основная частота микроконтроллера), равную максимальной (указана под данным полем), для STM32F427VI – 180 МГц.  
  设置微控制器的主频率HCLK为最高值（STM32F427VI的最高频率为180MHz）。

После этого STM32CubeIDE автоматически рассчитает настройки дерева синхронизации для получения нужных частот с учетом всех ограничений.  
配置完成后，STM32CubeIDE会自动计算同步树的设置，确保满足频率约束。

### 1.2. Интерфейс ввода-вывода общего назначения (GPIO)

Общие сведения о GPIO

Интерфейс ввода-вывода общего назначения (general-purpose input/output, GPIO) –
базовый интерфейс взаимодействия компьютерной системы с внешним миром. С его
помощью к контактам (ножкам, «пинам») микроконтроллера чаще всего подключаются
такие внешние элементы как светодиоды, кнопки, переключатели, осуществляется
управление периферийными устройствами и т. д.

Контакты микроконтроллера внутри подключаются к портам ввода-вывода. Пример организации единичного порта ввода-вывода приведен на рис. 3. Такие порты GPIO обычно объединяются в группы по 8, 16 или 32 порта с общими регистрами управления. Одни и те же порты могут выступать в роли входа или выхода в зависимости от настроек. По умолчанию обычно включен режим входа, чтобы исключить влияние порта на другие части схемы. Для работы в качестве выхода необходимо настроить соответствующий порт на выход при помощи управляющих регистров (описаны в документации микроконтроллера). Каждый контакт настраивается индивидуально – в одной группе портов входы и выходы могут чередоваться в любых комбинациях.

![](./pics/lecture1.2-1.png)

Рисунок 2 – Настройки дерева синхронизации микроконтроллера STM32F427VI

Также порты ввода-вывода позволяют в качестве «альтернативной функции» подключать к контактам микроконтроллера различные аппаратные блоки – контроллеры интерфейсов ввода вывода, генераторы сигналов и т. п.

В STM32 единичные порты GPIO объединяются в групповые порты по 16 штук, которые называются GPIOA, GPIOB и т. д. Соответствующие им контакты микроконтроллера называются PA1, PA2, …, PB1, PB2, … и т. д.

В стенде SDK-1.1M с процессорным модулем на базе STM32 на боковой панели имеется одна кнопка, подключённая к контакту PC15, и два управляемых светодиода: зеленый, подключенный к PD13, и двухцветный красный/желтый, подключенный к контактам PD14 и PD15 (рис. 4, 36).

Пример работы с GPIO в STM32

Произведем настройку контактов микроконтроллера в SDK-1.1M. В STM32CubeIDE в режиме конфигурирования микроконтроллера на вкладке Pinouts & Configuration необходимо перевести контакты PD13 – PD15 в режим GPIO_Output (рис. 5).

После сохранения конфигурации микроконтроллера STM32CubeIDE сгенерирует и добавит в проект код для инициализации микроконтроллера в соответствии с заданными настройками.

ВНИМАНИЕ: при повторной генерации файлов из них удаляется весь код, добавленный пользователем, кроме кода, который написан между парами комментариев вида /* USER CODE BEGIN ... */, /* USER CODE END ... */.

Для работы с GPIO, как и с другой периферией, на STM32 рекомендуется использовать библиотеку HAL (Hardware Abstraction Layer), поддержка которой встроена в IDE. При генерации проекта STM32CubeIDE добавляет в код функцию MX_GPIO_Init(), инициализирующую порты GPIO в соответствии с настройками:

```
static void MX_GPIO_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    __HAL_RCC_GPIOH_CLK_ENABLE();
    __HAL_RCC_GPIOD_CLK_ENABLE();
    __HAL_RCC_GPIOA_CLK_ENABLE();
    __HAL_RCC_GPIOB_CLK_ENABLE();
    HAL_GPIO_WritePin(GPIOD,GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET);
    GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
}
```

![](./pics/lecture1.2-2.png)

Рисунок 3 – Организация единичного порта ввода-вывода в STM32 [4]

![](./pics/lecture1.2-3.png)

Рисунок 4 – Подключение кнопки и управляемых светодиодов на принципиальной электрической схеме SDK-1.1M

![](./pics/lecture1.2-4.png)

Рисунок 5 – Окно настройки портов GPIO

Для установки значения на выход и чтения входа используются стандартные функции из библиотеки HAL:

```
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState);
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
```

Параметры:

– *GPIOx – выбор порта; указатель на контекст драйвера конкретного порта; буква «x»
соответствует имени порта; для управления светодиодами необходимо использовать
порт GPIOD;
– GPIO_Pin – номер контакта, например, GPIO_PIN_13;
– PinState – состояние контакта: GPIO_PIN_SET («1») или GPIO_PIN_RESET («0»).

Для выполнения задержки на заданное количество миллисекунд (активное ожидание), получения текущего значения миллисекундного счетчика используются следующие функции:

```
void HAL_Delay(uint32_t Delay);
uint32_t HAL_GetTick(void);
```

Пример кода, который переключает состояние зеленого светодиода каждые 500 мс:

```
while (1)
{
    HAL_GPIO_WritePin(GPIOD, GPIO_PIN_13, GPIO_PIN_RESET);
    HAL_Delay(500);
    HAL_GPIO_WritePin(GPIOD, GPIO_PIN_13, GPIO_PIN_SET);
    HAL_Delay(500);
}
```

Дребезг механических контактов

Механические контакты подвержены явлению дребезга. Его суть в том, что при замыкании контакта нажатием на кнопку напряжение устанавливается не сразу, а в течение некоторого времени (десятки миллисекунд) «скачет», пока контакт надежно не замкнется. После того, как кнопка будет отпущена, напряжение также «скачет», пока не установится на нужном уровне (рис. 6). Такое многократное замыкание/размыкание контактов вызвано тем, что контакты пружинят, обгорают и т. п.

![](./pics/lecture1.2-5.png)

Рисунок 6 – Пример временной диаграммы напряжения цепи при нажатии кнопки с дребезгом контактов

Поскольку процессор реагирует на события очень быстро, то он может воспринять эти скачки напряжения за несколько нажатий. Решить данную проблему можно как аппаратно с помощью RS-триггера или триггера Шмитта, так и программно посредством отслеживания временных интервалов между замыканием и размыканием контактов.

Например, можно использовать небольшую задержку перед следующим опросом кнопки после фиксации замыкания. Задержка подбирается такой, чтобы дребезг успел прекратиться к ее окончанию. Если второй опроса также показал, что контакт замкнут, можно считать, что кнопка нажата.

Использование сигнала от кнопки как внешнего прерывания из-за дребезга требует реализации специальных механизмов ожидания и использования таймеров, поэтому является более сложным. Еще одним вариантом является постоянный периодический опрос состояния сигнала кнопки по прерыванию от таймера (будет рассмотрено в следующих разделах). 

В SDK-1.1M аппаратная защита от дребезга не реализована, поэтому необходимо предусматривать один из вариантов программной защиты.

### 4.1. Подключение стенда к компьютеру

Стенд SDK-1.1M подключается к персональному компьютеру через разъем «DBG USB» (см. рис. 36) кабелем с разъемом USB 2.0 Micro-B (входит в комплект поставки стенда). После подключения на лицевой панели стенда должен загореться светодиодный индикатор «VTGT».

Через разъем «DBG USB» обеспечивается электропитание стенда, а также подключение компьютера к встроенному программатору-отладчику стенда. Программатор-отладчик предназначен для загрузки программ в стенд и их отладки. Он обеспечивает подключение к вычислителю процессорного модуля по интерфейсам JTAG и UART (в режиме виртуального COM-порта). Через JTAG происходит взаимодействие с отладочной инфраструктурой вычислителя, а UART можно использовать для организации пользовательского отладочного ввода-вывода.

Для выключения стенда необходимо отключить его от компьютера.

ВНИМАНИЕ: когда стенд не используется, рекомендуется отключать USB-кабель от стенда во избежание случайного механического повреждения USB-разъема.

4.2. Установка драйверов встроенного программатора-отладчика 

Встроенный программатор-отладчик SDK-1.1M построен с применением универсальной микросхемы-конвертера интерфейса USB фирмы FTDI [31]. Подключение с инструментального компьютера к программатору-отладчику выполняется с использованием специального драйвера USB и открытого фреймворка OpenOCD.

При первом использовании SDK-1.1M требуется установить на компьютер необходимые драйверы, как указано ниже.

Процедура установки драйверов для macOS
Установка драйверов для macOS не требуется.

4.3. Инструментальные средства разработки для микроконтроллеров STM32

Для разработки и отладки программ для микроконтроллеров семейства STM32 рекомендуется использовать среду разработки STM32CubeIDE [21], которая доступна для скачивания с сайта производителя [34].

STM32CubeIDE – это интегрированная среда разработки (IDE), которая включает:
– графический конфигуратор STM32CubeMX (Micro eXplorer; также доступен в виде отдельного приложения), позволяющий выбирать желаемую конфигурацию блоков микроконтроллера STM32 и генерировать шаблоны проектов с необходимым кодом инициализации на языке C или C++ посредством наглядного пошагового процесса (рис. 39);

– поддержку стандартной библиотеки драйверов (HAL) и дополнительных программных модулей (middleware);
– классические средства редактирования кода, сборки и отладки проектов.