## [MainPage](../../index.md)/[Computer Vision](../README.md)/[Lecture](../Lecture.md)/7-3 RAW

语音识别：Youtube 转文本  
断句与标点：chatGPT 4o  
翻译：chatGPT 4o  

Так мы плавно подошли к идее создания хэш-функции от изображения. Отметим, что хэш-функция может считаться не только на основе явно выделенных низкоуровневых примитивов, таких как контуры и ключевые точки, как было рассмотрено ранее, но и напрямую получаться из представления изображения либо от несколько модифицированного предварительно сырого представления изображения.  
这样，我们逐渐接近了创建图像哈希函数的想法。需要注意的是，哈希函数不仅可以基于明确提取的低级别特征（如轮廓和关键点）来计算，如之前所讨论的那样，还可以直接从图像的表示或略微修改后的原始图像表示中获得。

Также отметим, что существует особый класс таких хэш-функций, которые мы будем рассматривать дальше и которые нам наиболее интересны, обладающих специальными перцептивными свойствами. Это заключается в том, что чем ближе по целевой метрике значения хэш-функции от двух исходных изображений, тем ближе друг другу эти изображения с точки зрения человеческого восприятия. То есть тем более вероятно, что они похожи. Таким образом, задача сравнения изображений или поиска дубликатов может быть сведена к вычислению их перцептивных хэш-значений и нахождению расстояния между ними согласно целевой метрике, вынесению определенного вердикта о схожести данных изображений. Как правило, перцептивные алгоритмы, основанные на извлечении хэш-значений из сырого представления изображения, довольно просты в реализации, интерпретируемы и хорошо подходят для поиска похожих изображений по базам данных путем сравнения хэшей. Это предоставляет довольно удобный способ для поиска дубликатов или хотя бы для его оптимизации, а также фильтрации контента на определенном конвейере, что подчеркивает особую важность данных подходов.  
还需指出，存在一种特殊类别的哈希函数，它们具备独特的感知特性，这些特性是我们接下来要讨论的，并且对我们最有吸引力。这意味着，如果两个原始图像的哈希函数值在目标度量上越接近，那么这些图像在人的感知上也越接近。也就是说，它们更有可能相似。因此，比较图像或查找重复项的任务可以简化为计算它们的感知哈希值并根据目标度量找到它们之间的距离，进而得出关于这些图像相似性的结论。通常，基于从原始图像表示中提取哈希值的感知算法实现起来相对简单，易于解释，非常适合通过比较哈希值在数据库中查找相似图像。这为查找重复项或至少优化查找过程以及在特定流水线中过滤内容提供了非常方便的方法，强调了这些方法的特殊重要性。

Рассмотрим далее самые популярные распространенные методы перцептивного хэширования, основанные на получении хэш-значений из сырого представления изображения или чуть модифицированного.  
接下来，我们将讨论一些最流行的感知哈希方法，这些方法基于从原始图像表示或略微修改后的表示中获取哈希值。

Теперь мы рассмотрим алгоритм aHash, или простой перцептивный хэш (average hash). Это самый лёгкий для реализации из алгоритмов перцептивного хэширования, которые мы сегодня рассмотрим. Его отличительной чертой является то, что работа основана на проверке на среднее значение по всем точкам изображения, что следует из названия. Рассмотрим подробнее шаги этого алгоритма.  
现在我们来看一个名为aHash（平均哈希）的算法，也称为简单的感知哈希。这是我们今天讨论的感知哈希算法中最容易实现的。其显著特征是基于图像所有点的平均值进行工作，这也反映在其名称中。我们详细看看这个算法的步骤。

На первой стадии происходит уменьшение размера изображения. При этом, чем больше уменьшенное изображение, тем более точным будет результат, но на это потребуется больше времени. Обычно при реализации этого алгоритма изображение сжимается до квадрата 8 на 8 пикселов. Данная операция выполняется для избавления от высоких частот. На втором шаге происходит перевод сжатого изображения в градации серого, в результате чего размер хэша становится в три раза меньше, так как происходит уменьшение количества цветовых компонентов с 3 в модели RGB до 1, которая обозначает уровень серого. Данное преобразование происходит по формуле, представленной на слайде, где I и J обозначают позицию пикселя на изображении, R, G и B — значение цветов пикселов в пространстве RGB.  
第一步是缩小图像的尺寸。缩小后的图像越大，结果就越准确，但需要更多时间。通常，在实现这个算法时，图像会被压缩成8×8像素的方块。这个操作是为了去除高频部分。第二步是将压缩后的图像转换为灰度级，这样哈希的大小会减少三倍，因为颜色分量从RGB模型中的3个减少到1个，表示灰度级。这个转换过程按照幻灯片上展示的公式进行，其中I和J表示图像上像素的位置，R、G和B表示RGB空间中的像素颜色值。

На третьем шаге происходит поиск среднего значения. Для этого необходимо вычислить среднее значение по всем шестидесяти четырем точкам уменьшенного монохромного изображения. На четвёртом шаге происходит построение битовой цепочки в зависимости от того, является ли значение пиксела больше среднего или меньше. В зависимости от этого в конец цепочки записывается 1 или 0. На пятом шаге происходит построение самого хэша. Для этого необходимо перевести шестьдесят четыре отдельных бита в одно 64-битное значение. Порядок при этом не имеет значения, но принято записывать биты, начиная с левого верхнего угла и заканчивая правым нижним. Данный алгоритм достаточно быстрый, при этом он чувствителен к операциям, изменяющим среднее значение, то есть чувствителен к изменению цветового баланса, так как он основан на средних значениях цветов.  
第三步是计算平均值。需要计算缩小后单色图像的64个点的平均值。第四步是构建比特链，根据像素值是大于还是小于平均值来决定是记录1还是0。第五步是构建哈希，为此需要将64个独立的比特转换成一个64位的值。顺序无关紧要，但通常从左上角开始记录比特，最后到右下角。这个算法相当快速，但对改变平均值的操作敏感，即对颜色平衡的改变敏感，因为它基于颜色的平均值。

Рассмотрим далее очередной алгоритм перцептивного хэширования изображений. Он так и называется pHash (perception hash) и во многом повторяет шаги aHash, но кроме того ещё выполняет дискретное косинусное преобразование, которое делит исходное изображение на гармоники дискретного сигнала, влияющие на качество изображения.  
接下来我们讨论另一个感知哈希算法，称为pHash（感知哈希），在很多方面重复了aHash的步骤，但还执行了离散余弦变换，将原始图像分解为影响图像质量的离散信号的谐波。

Рассмотрим подробнее шаги данного алгоритма. Во-первых, производится уменьшение изображения до квадрата размером 32 на 32 пикселя. Далее происходит перевод изображения в монохромное. После этого производится дискретное косинусное преобразование, разбивающее изображение на набор частотных векторов. Здесь M и N определяют размер входной матрицы, I и J обозначают позицию пикселя, а V обозначает значение интенсивности пиксела в соответствующей позиции, заданной координатами. F представляет собой коэффициент из матрицы дискретного косинусного преобразования, располагающийся на строке, соответствующей первому аргументу, и столбце, соответствующему второму.  
我们详细看看这个算法的步骤。首先，将图像缩小到32×32像素的方块。然后将图像转换为单色。接着执行离散余弦变换，将图像分解为一组频率向量。这里M和N确定输入矩阵的大小，I和J表示像素的位置，V表示像素在指定坐标位置的强度值。F表示离散余弦变换矩阵中的系数，位于对应第一个参数的行和第二个参数的列。

Далее происходит сокращение, то есть сохраняется только левый верхний блок размером 8 на 8 из дискретного косинусного преобразования. То есть нам необходимы низкочастотные компоненты изображения, высокочастотные компоненты, располагающиеся ближе к правому нижнему углу, не несут особой ценности. После этого происходит вычисление среднего значения. На этом шаге требуется убрать из расчета самый первый коэффициент, чтобы исключить из описания хэша пустую информацию, например одинаковые цвета. Далее происходит присвоение каждому из 64 значений дискретного косинусного преобразования нуля или единицы в зависимости от того, больше оно или меньше среднего значения. После этого происходит получение результата нашего алгоритма — 64 бита превращаются в 64-битное значение. Такой алгоритм уже способен выдержать изменения гистограммы изображения или его гамма-коррекцию. pHash нечувствителен к изменению контрастности, яркости и к масштабированию.  
接着进行简化，即只保留离散余弦变换的左上角8×8的块，也就是说，我们只需要图像的低频成分，靠近右下角的高频成分没有特别的价值。然后计算平均值。这一步需要排除第一个系数，以避免将无效信息（如相同的颜色）纳入哈希描述。接着，将64个离散余弦变换值中的每一个根据其是否大于或小于平均值分配0或1。最后，得到算法的结果——64个比特转换成一个64位的值。这个算法已经能够承受图像直方图的变化或其伽马校正。pHash不受对比度、亮度和缩放变化的影响。

Следующий рассматриваемый нами подход всё-таки использует некоторую информацию о градиентах изображения. dHash или difference hash прост в реализации, обладает высокой скоростью и точностью работы и основан на отслеживании градиента изображения. Рассмотрим подробнее шаги данного алгоритма. Во-первых, как и в прошлых алгоритмах, происходит уменьшение размера изображения до фиксированного. В общем случае размер — N+1 на N. Далее происходит перевод изображения в оттенки серого. После этого происходит вычисление разницы между следующим и предыдущим пикселом. В результате получается матрица. Следует отметить, что данная матрица уже квадратная. После этого происходит построение битовой цепочки: если значение текущего пиксела больше предыдущего, то значение хэша принимается за 1, в противном случае — 0. В итоге происходит построение результирующего хэш-значения. Требуется перевести шестьдесят четыре отдельных бита в одно 64-битное значение. Это можно сделать с помощью подходов, которые мы уже рассматривали ранее.  
我们将讨论的下一个方法仍然使用一些图像梯度信息。dHash（差异哈希）简单易行，具有高速度和准确性，基于跟踪图像梯度。我们详细看看这个算法的步骤。首先，与之前的算法一样，将图像缩小到固定尺寸。通常情况下尺寸为N+1×N。接着将图像转换为灰度级。然后计算相邻像素之间的差异。结果是一个矩阵。需要注意的是，这个矩阵已经是方形的。接着构建比特链：如果当前像素值大于前一个像素值，则哈希值为1，否则为0。最终得到的是64个比特的哈希值。这可以通过我们之前讨论的方法将64个独立的比特转换成一个64位的值。

Отметим, что все рассмотренные ранее перцептивные хэши имеют примерно одну и ту же последовательность, в смысле сходные стадии обработки изображений. При этом если модифицировать различные стадии и по-разному их комбинировать, то можно составлять свои перцептивные хэши и исследовать эмпирически их эффективность. Одной из таких вариаций является gHash или градиентный хэш. За основу был взят алгоритм dHash. Опытным путем было выявлено, что отслеживание градиента изображения по столбцам и строкам не менее эффективно по пиксельного метода, лежащего в основе dHash.  
需要注意的是，所有之前讨论的感知哈希大致有相同的处理图像的步骤序列。通过不同的组合和修改这些步骤，可以创建自己的感知哈希，并通过经验研究其有效性。其中一种变体是gHash（梯度哈希），其基础是dHash算法。通过实验发现，按列和行跟踪图像梯度的方法与dHash的像素级方法同样有效。

Таким образом, возникают следующие шаги. На первом шаге также происходит уменьшение размера изображения, к примеру, до квадрата со стороной 32 на 32 пикселя. После этого изображение также переводится в оттенки серого. После этого строится битовая цепочка: каждому столбцу присваивается единица или 0 в зависимости от того, больше или меньше сумма значений его пикселов в сравнении со следующим столбцом. Далее происходит запись этого значения в конец битовой строки. Аналогичная операция проводится со строками. В результате получается цепочка из 64 бит. После этого происходит построение хэша. Для этого требуется перевести шестьдесят четыре отдельных бита в одно 64-битное значение. Сделать это можно тем же образом, что мы делали в предыдущих перцептивных хэшах.  
因此，步骤如下：第一步同样是缩小图像尺寸，例如缩小到32×32像素的方块。接着将图像转换为灰度级。然后构建比特链：每一列根据其像素值总和与下一列的比较结果分配1或0。然后将该值记录到比特链的末尾。类似的操作也适用于行。结果是一个64比特的链。接着构建哈希，需要将64个独立的比特转换成一个64位的值。这可以通过之前的方法完成。

Если допустить, что изображение уменьшается до квадрата со стороной N пикселов, то пренебрегая способом масштабирования изображений, сложности алгоритмов aHash, pHash и dHash можно определить как O(N^4), O(N^2) и O(N^2) соответственно. Также следует отметить, что в оценке сложности алгоритма pHash большую роль играют затраты на вычисления дискретного косинусного преобразования.  
如果假设图像缩小到N像素的方块，则忽略图像缩放方式，aHash、pHash和dHash算法的复杂度分别为O(N^4)、O(N^2)和O(N^2)。还需注意，在评估pHash算法的复杂度时，离散余弦变换的计算开销起着重要作用。