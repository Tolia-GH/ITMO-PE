## [MainPage](../../index.md)/[Computer Vision](../README.md)/[Lecture](../Lecture.md)/7-3 RAW

语音识别：Youtube 转文本
断句与标点：
翻译：

так мы плавно пошли к идее создания хэш-функции от изображения отметим что хэш функция может считаться не только на основе явно выделенных низкоуровневых примитивов таких как контуры и ключевые точки как была рассмотрена ранее но и напрямую получаться эзра представления изображения либо от несколько модифицированного предварительно сырого представление изображения также отметим что существует особый класс таких хэш-функций которые мы будем рассматривать дальше и который нам наиболее интересен обладающих специальным перцептивном свойствам которое заключается в том что чем ближе по целевой метрики значения хэш-функции от двух исходных изображений тем ближе друг другу эти изображения с точки зрения человеческого восприятия то есть тем более вероятно что они похожи таким образом задачи сравнения изображений или поиска дубликатов может быть сведено к вычислению их принцип туале хэш значений нахождение расстояния между ними согласны целевой метрики вы внесения определенного вердикта о схожести данных изображений как правило перцептивные алгоритмы основанные на извлечение хэш значения напрямую строго представления изображения довольно просты в реализации интерпретируем и и хорошо подходит для поиска похожих изображений по базам данных путем сравнения вшей что предоставляет довольно удобный способ для поиска дубликатов или хотя бы для его оптимизации а также фильтрации контента на определенном конвейере что подчеркивает особую важность данных подходов рассмотрим далее самые популярные распространенные методы перцептивного хэширования основанные на получение хэш значений и строго представления изображения или чуть модифицированного теперь мы рассмотрим и верещишь или простой перцептивный hash hash это самый лёгкий для реализации из алгоритмов персонального хэширования которые мы сегодня рассмотрим его отличительной чертой является то что работа основана на проверке на среднее значение по всем точкам изображения что следует из названия рассмотрим подробнее шаги этого алгоритма на первой стадии происходит уменьшение размера при этом чем больше уменьшенное изображение тем более точным будет результат но на это потребуется больше времени обычно при реализации этого алгоритма изображение сжимается до квадрата 8 на 8 пикселов данная операция выполняется для избавления от высоких частот на втором шаге происходит перевод сжатого изображения в градации серого в результате чего размер кэша становится в три раза меньше так как происходит уменьшение количества цветовых components 3 в модели orgy беда 1 которая обозначает уровень серого данное преобразование происходит по формуле представленной на слайде где i&g обозначают позицию пикселя на изображении art baby значение цветов пикселов пространство orgy бен на третьем шаге происходит поиск среднего для этого необходимо вычислить среднее значение по всем шестидесяти четырем точкам уменьшенного монохромного изображения на четвертом шаге происходит построение битовой цепочки зависимости от того является ли значение пик сего больше среднего или меньше в зависимости от этого в конец цепочки записывается и делиться или 0 на пятом шаге происходит построение самого хэша для этого необходимо перевести шестьдесят четыре отдельных битов одно 64-битное значение порядок при этом не иметь значение но принято записывать биты начиная с левого верхнего угла и заканчивая правым нижним данный алгоритм достаточно быстрый при этом он чувствителен к операциям изменяющим среднее значение то есть чувствительны к изменению цветового баланса так как он основан на средних значениях цветов рассмотрим далее очередной алгоритм виртуального хэширования изображений он так и называется perception хэш или пихаешь и во многом повторяет шаги и хэш но кроме того еще выполняя дискретная косинус преобразования которое делит исходное изображение на гармонике дискретного сигнала влияющие на качество изображения рассмотрим подробнее шаги данного алгоритма во-первых производится уменьшение изображения до квадрата размером 32 на 32 пикселя далее происходит перевод изображение в монохромные после этого производится дискретная косинус преобразования разбивающие изображение на набор чистоты векторов здесь mn определяют размер входной матрицы iv малая определяет значение интенсивности пиксела в соответствующей позиции заданными координатами f большое представляет собой коэффициент из матрицы дискретного косинус преобразование располагающийся на строке соответствующий первому аргументу и столбце соответствующему второму далее происходит сокращение то есть сохраняются только левый верхний блок размером 8 на 8 из дискретного косинус преобразования то есть нам необходимы низкочастотные компоненты изображения высокочастотные компоненты располагающиеся ближе к правому нижнему углу не несут особой ценности после этого происходит вычисление среднего значения на этом шаге требуется убрать из расчета самый первый коэффициент чтобы исключить из описания хэша пустую информацию например одинаковые цвета далее происходит присвоение каждому из 64 значений дискретного косинус преобразование нуля или единицы в зависимости от того больше она или меньше среднего значения после этого происходит получение результата нашего алгоритма 64 бита превращаются в 64-битное значение такой алгоритм уже способен выдержать изменения гистограмма изображения или его гамма коррекцию пихаешь нечувствителен к изменению контрастности яркости и к масштабированию следующий рассматриваемый нами подход все-таки используют некоторую информацию о градиентах изображения де хэш elli di firenze прост в реализации обладает высокой скоростью и точностью работы и основан на отслеживание градиента изображения рассмотрим подробнее шаги данного алгоритма во первых как и в прошлых алгоритмах происходит уменьшение размера изображения до фиксированного в общем случае размеры n плюс 1 на н далее происходит перевод изображения в оттенки серого после этого происходит вычисление разницы между следующем и предыдущем миксе вам в результате получается матрица следует отметить что данная матрица уже квадратная после этого происходит построение битовой цепочки если значение текущего пиксела больше предыдущего то значение х ш принимается в единицу в противном случае 0 в итоге происходит построение результирующего х значения требуется перевести шестьдесят четыре отдельных битов в одно 64-битное значение это можно сделать с помощью подходов которые мы уже рассматривали ранее отметим что все рассмотренные ранее перцептивные хэши имеют примерно одну и ту же последовательность в смысле сходные стадии обработки изображений при этом если модифицировать различной стадии и по-разному их комбинировать то можно составлять свои перцептивные хэши исследовать эмпирически их эффективность одной из таких вариаций является g хэш или градиент хэш за основу был взят алгоритм де хэш опытным путем было выявлено что отслеживание градиента изображения по столбцам и строкам не менее эффективна по пиксельного метода лежащего в основном diffusion таким образом возникают следующие шаги на первом шаге также происходит уменьшение размера изображения к примеру до квадрата со стороной 32 на 32 пикселя после этого изображение также переводится в оттенки серого после этого строится битовая цепочка каждому столбцу присваивается единица или 0 в зависимости от того больше или меньше сумма значений его пикселов в сравнении со следующим столбцом далее происходит запись этого значения в конец битвы и строки аналогичные 18 операций проводится со строками в результате получается цепочка из 64 bit of после этого происходит построение хэша для этого требуется перевести шестьдесят четыре отдельных битов в одно 64-битное значение сделайте это можно тем же образом что мы делали в предыдущих персональных и шах если допустить что изображение уменьшается до квадрата со стороной and пикселов то пренебрегает способом масштабирования изображений сложности алгоритмов и их ешь пишешь-пишешь и джйотиш можно определить как у большое-большое от n в четвертой степени у большое от n в квадрате и о большой от n в квадрате соответственно также следует отметить что в оценки сложности алгоритма ты их ешь большую роль играют затраты на вычисления дискретного косинус преобразования 