## [MainPage](../../index.md)/[Computer Vision](../README.md)/[Lecture](../Lecture.md)/4-5 RAW

语音识别：Youtube 转文本  
断句与标点：chatGPT 4o  
翻译：chatGPT 4o  

Метод для вычисления потока по данной схеме и предлагает алгоритм Лукаса-Канады. Итак, алгоритм Лукаса-Канады - это дифференциальный локальный метод вычисления оптического потока. Метод основан на предположении, что в локальной окрестности каждого пиксела значение оптического потока одинаково. Таким образом, можно записать основное уравнение оптического потока для всех пикселов окрестности и решить полученную систему уравнений методом наименьших квадратов.  
计算流的方法提出了Lucas-Kanade算法。Lucas-Kanade算法是一种差分的局部光流计算方法。该方法基于这样的假设，即在每个像素的局部邻域中，光流的值是相同的。因此，可以为邻域中的所有像素写出光流的基本方程，并通过最小二乘法求解所得的方程组。

Теперь подробнее разберем данный метод. Будем решать задачу нахождения оптического потока, которую мы рассмотрели на предыдущем слайде. Будем исходить из соображения, что на изображении представлены объекты размером больше одного пиксела. Значит, скорее всего, в окрестности текущей точки у других точек будут примерно такие же сдвиги. Поэтому мы возьмем окно вокруг этой точки и минимизируем по методу наименьших квадратов. Вот таким образом выглядит наше решение.  
现在让我们更详细地讨论这个方法。我们将解决前一张幻灯片中提到的光流计算问题。我们假设图像中显示的对象大小超过一个像素。因此，在当前点的邻域中，其他点可能具有相似的位移。因此，我们在该点周围取一个窗口，并通过最小二乘法进行最小化。我们就是这样进行求解的。

Алгоритм Лукаса-Канады менее чувствителен к шумам на изображениях, чем точечные методы. Однако он является сугубо локальным и не может определить направление движения пикселов внутри однородной области. Однако существует весьма неприятное обстоятельство, которое носит название проблема апертуры. Это неоднозначность при ограниченном поле зрения для периодических картинок. Она соответствует случаю, когда в поле зрения попадает фрагмент изображения, в котором присутствует некоторая цикличность. Тут уж и человек не сможет однозначно определить, куда картинка сместилась. Проблема в том, что из-за шумов в таких неоднозначных ситуациях мы получаем не нулевые детерминанты, а очень маленькие, что, скорее всего, приведет к очень большому значению сдвига, особо не коррелирующему с действительностью. Так что на определенном этапе нужно просто проверять, не является ли детерминант системы достаточно маленьким, и если да, рассматривать такие точки или отмечать их как ошибочные.  
Lucas-Kanade算法对图像噪声不太敏感，优于点方法。然而，该方法是严格局部的，无法确定均匀区域内像素的运动方向。但存在一个被称为孔径问题的非常棘手的情况。对于周期性图像来说，有限视野内的这种不确定性对应于一种情况，即视野内的图像片段呈现出一定的周期性。在这种情况下，即使是人也无法确定图像移动的方向。问题在于，由于噪声，在这些不确定的情况下，我们得到的不是零行列式，而是非常小的行列式，这很可能导致非常大的位移值，与实际情况不符。因此，在某些情况下，需要检查行列式是否足够小，如果是，则将这些点视为错误或标记为错误点。

Другим слабым местом алгоритма является то, что мы имеем дело не с гладкими непрерывными функциями, а с произвольными, да еще и с дискретными. Поэтому на некоторых фрагментах изображения интенсивность может скакать вообще без явных закономерностей, например на границах объектов из-за шумов. В этом случае никакая функция не сможет достаточно точно описать изменение изображения в окрестности точки. Чтобы с этим бороться хотя бы частично, предлагается исходное изображение размазать, причем полезно будет его размазать достаточно сильно. То есть лучше применять даже всеми любимый гауссовский блюринг, но или усреднение с весовыми коэффициентами Гаусса, а прямо-таки боксовый фильтр или равномерное усреднение по окну да еще несколько раз подряд. Гладкость изображения для нас сейчас важнее, чем детализация.  
该算法的另一个弱点在于，我们处理的不是平滑的连续函数，而是任意的、离散的函数。因此，在图像的某些片段上，强度可能会无规律地跳变，例如，由于噪声在对象边界处。在这种情况下，没有任何函数能够准确描述点邻域内的图像变化。为了解决这个问题，建议对原始图像进行模糊处理，并且最好进行较强的模糊处理。也就是说，最好使用常用的高斯模糊，或者使用带有高斯权重的均值滤波器，甚至直接使用方框滤波器或在窗口上多次均匀平滑处理。对于我们而言，现在图像的平滑度比细节更重要。

Обычный Лукс-Канада хорошо определяет маленькие сдвиги, в рамках которых картинка похожа на свое линейное приближение. Чтобы с этим бороться, воспользуемся стандартным приемом компьютерного зрения - масштабированием. Построим пирамиду изображений разного масштаба. Почти всегда берется масштабирование в два раза по каждой оси, так проще производить вычисления. Далее производится проход по ним оптическим потоком от меньшего изображения к большему. Тогда редактированные маленький сдвиг на маленьком изображении будет соответствовать большому сдвигу на большом изображении. На самом маленьком изображении мы обнаружим сдвиг в более одного-двух пикселов, а переходя от меньшего масштаба к большему, мы пользуемся результатом с предыдущего шага и уточняем значения сдвига.  
普通的Lucas-Kanade算法很好地识别小位移，其中图像类似于其线性近似。为了应对这一问题，我们使用计算机视觉中的标准技术——多尺度方法。构建不同尺度的图像金字塔。几乎总是以每个轴上缩放两倍的方式进行缩放，这样计算起来更简单。然后，我们从较小的图像到较大的图像进行光流计算。然后，较小图像上的小位移将对应于较大图像上的大位移。在最小的图像上，我们可以检测到超过一两个像素的位移，并通过从较小的尺度逐渐过渡到较大的尺度，利用前一步的结果，精确调整位移值。

Подобный метод в библиотеке компьютерного зрения OpenCV реализует функция calcOpticalFlowPyrLK. Собственно говоря, это некоторое сокращение от выражения "вычисление оптического потока с помощью пирамидальной вариации алгоритма Лукаса-Канады". Использование этого пирамидального алгоритма позволяет не сталкиваться с проблемами вычисления линейной аппроксимации по многим точкам, проще взять больше уровней пирамиды, а на каждом уровне брать довольно грубое приближение этой функции. Поэтому в пассиве идет расчет всего по двум соседним точкам, и поэтому применительно к этой реализации алгоритма умозаключения о преимуществах аппроксимирующей функции перед производной оказываются бесполезными: для такого количества опорных точек производная есть лучшая аппроксимирующая функция.  
在计算机视觉库OpenCV中，calcOpticalFlowPyrLK函数实现了类似的方法。实际上，这个函数名是“通过Lucas-Kanade算法的金字塔变体计算光流”的缩写。使用这种金字塔算法，可以避免通过许多点计算线性逼近的问题，更容易采用更多金字塔级别，并在每个级别上使用相当粗略的近似函数。因此，计算仅限于两个相邻点，对于这种实现来说，逼近函数的优势在于导数是最佳逼近函数，因为参考点数量太少。

Рассмотрим еще одну полезную модификацию данного алгоритма, которая, как правило, используется по умолчанию, но для упрощения понимания мы не включили ее в общее описание алгоритма в наших предыдущих рассуждениях. В методе наименьших квадратов всем пикселам в окне q оказывается одинаковое влияние. Однако логичнее учитывать, что более близкие к p пикселы должны наделяться большим весом. Для этого используется взвешенный метод наименьших квадратов, то есть окрестность поточечно домножаем на гауссово ядро соответствующего размера, чтобы значимость точек падала в зависимости от удаления от интересующего нас центра. Это особенно актуально в реальных условиях применения алгоритма.  
让我们再看一下这种算法的另一种有用的改进，通常默认使用，但为了简化理解，我们在前面的描述中没有包含它。在最小二乘法中，窗口q内的所有像素的影响都是相同的。然而，考虑到更接近p的像素应具有更大的权重是更合理的。为此，使用加权最小二乘法，即逐点乘以相应大小的高斯核，以便点的权重随着距离中心点p的增加而减少。在实际应用中，这尤其重要。

После того как мы слегка погрузились в предметную область и получили некоторое понимание того, как можно представлять, фиксировать и описывать движение интересующего нас объекта на видео на примере базовых идей вокруг локального оптического потока и смещения масок, то есть трекинга "блобов" своего рода, перейдем к рассмотрению современных подходов для решения задачи трекинга объектов с использованием механизмов глубокого обучения.  
在我们稍微深入到主题领域，并获得了一些关于如何表示、固定和描述视频中感兴趣对象运动的基本想法之后，我们将转向现代方法，使用深度学习机制解决对象跟踪问题。

Но перед тем как перейти к современным методам, отметим, что большинство классических подходов страдают от отсутствия хорошего дискриминационного описания объектов. Более того, на практике приходится постоянно уточнять результаты трекинга детектированием. Поэтому современные трекеры по большей части совмещают в себе механизмы трекинга и механизмы детектирования и извлечения дескриптора объектов. Это становится возможным, поскольку современные детекторы работают довольно быстро, а процесс регрессии боксов при достаточно высоком FPS также не представляет проблем.  
但是在介绍现代方法之前，我们要指出，大多数传统方法由于缺乏良好的对象判别描述而存在问题。此外，在实践中，通常需要通过检测来不断调整跟踪结果。因此，现代跟踪器大多结合了跟踪和检测及提取对象描述符的机制。这变得可能，因为现代检测器运行速度相当快，而在相对较高的FPS下回归框的过程也不会带来问题。

Первым рассмотрим подход ROLO. Данный метод производит трекинг одного объекта, объединяя обнаружение объекта и рекуррентные нейронные сети. ROLO - это комбинация YOLO (или попросту YOLO, метода детектирования, который мы рассматривали на одной из предыдущих лекций) и LSTM (рекуррентной нейросети, которая используется для связи боксов между кадрами). На самом деле суть подхода предельно проста. При обработке очередного кадра производится детектирование объекта с помощью ван-шот детектора YOLO, после чего производится регрессия bounding бокса с помощью LSTM. В принципе топология сети проста и понятна. Однако авторы оригинальной статьи заостряют свое внимание на одном примечательном моменте, а именно на способе передачи позиции бокса на изображение. Дело в том, что передавать координаты, которые выделяет YOLO, напрямую сложно, так как это требует серьезной дополнительной нелинейности для возможности их интерпретации LSTM. Для этого используется heatmap исходного изображения, который содержит маску положения детектирования объекта на исходном изображении. Данный heatmap разворачивается вектором и конкатенируется с выходом предыдущего этапа сети и вектором, после чего подается в качестве очередного входа LSTM для регрессии bounding боксов.  
首先介绍ROLO方法。该方法通过结合对象检测和递归神经网络实现单个对象的跟踪。ROLO是YOLO（或只是YOLO，一种我们在前一讲中讨论的检测方法）和LSTM（用于连接帧之间边框的递归神经网络）的组合。事实上，这种方法的核心非常简单。在处理下一帧时，通过YOLO单次检测器进行对象检测，然后通过LSTM进行边框回归。网络的拓扑结构简单明了。然而，原始论文的作者强调了一个显著的方面，即对象位置的传递方式。问题在于，直接传递YOLO生成的坐标非常困难，因为这需要严重的附加非线性来使其LSTM理解。为此，使用了包含对象检测位置的heatmap。这张heatmap展开成向量，并与网络前一阶段的输出和向量连接，然后作为LSTM的下一个输入进行边框回归。

Поговорим немного про обучение данной архитектуры. Тут тоже нет ничего экстраординарного. Части, отвечающие за детектирование, представляют собой обычный детектор на базе YOLO. А что касается регрессионной LSTM надстройки, то она обучается с помощью минимизации MSE loss, причем лосс можно уменьшать как в контексте heatmap, так и в контексте пространства координат bounding боксов.  
我们稍微讨论一下这种架构的训练。实际上，这并不复杂。负责检测的部分就是基于YOLO的普通检测器。而回归LSTM部分则通过最小化均方误差（MSE）损失来训练，可以在heatmap上下文中，也可以在边框坐标空间中减少损失。

Далее рассмотрим хорошо зарекомендовавший себя подход SORT. Данный метод решает задачу multi-object tracking. В основе SORT лежит использование высокоточного детектора, так как это напрямую влияет на производительность всего процесса трекинга. В качестве детектора используется Faster R-CNN. Для сопоставления траекторий и обнаружения новых объектов используется Венгерский алгоритм, а также для предсказаний и корректировки bounding боксов используется фильтр Калмана. Венгерский алгоритм предоставляет возможности для объединения результатов детектирования на последовательных кадрах в траектории как на основе intersection over union метрики, которую мы рассматривали в одной из предыдущих лекций, так и на основе сходства формы или же различных дескрипторов, в том числе и полученных с помощью сверточных кодировщиков.  
接下来介绍表现良好的SORT方法。该方法解决多对象跟踪问题。SORT的核心是使用高精度检测器，因为这直接影响整个跟踪过程的性能。检测器采用Faster R-CNN。为了匹配轨迹和检测新对象，使用了匈牙利算法，并用卡尔曼滤波器进行边框预测和校正。匈牙利算法提供了在连续帧中将检测结果组合成轨迹的可能性，基于我们在前一讲中讨论的交并比（intersection over union）度量，或者基于形状相似性或不同描述符，包括通过卷积编码器获得的描述符。

Работа фильтра Калмана на bounding боксов мы рассмотрим далее. Вспомним, что фильтр Калмана состоит из двух стадий: предсказания позиции и обновления параметров. Таким образом, происходит своего рода сглаживание траектории вдоль направления смещения и коррект ировка параметров при поступлении новых данных от детектора. На слайде представлена простейшая механика предсказания следующего положения bounding бокса. Фаза обновления выглядит достаточно стандартно для фильтра Калмана, поэтому здесь мы рассматриваем только фазу предсказания для рассмотрения формы обрабатываемых значений.  
我们随后讨论卡尔曼滤波器在边框上的工作。记得卡尔曼滤波器由两个阶段组成：位置预测和参数更新。因此，沿着位移方向对轨迹进行平滑，并在检测器提供新数据时对参数进行校正。幻灯片上展示了下一位置边框预测的基本机制。更新阶段对于卡尔曼滤波器来说相当标准，因此在这里我们只讨论预测阶段以了解处理值的形式。

Отметим также, что у метода SORT есть улучшение, основанное на глубоком обучении. Оно носит соответствующее название Deep SORT. Данное улучшение основано на явном закреплении за каждым объектом его дескриптора, который получается в результате обработки области нахождения этого объекта с помощью глубокого нейросетевого feature extractor, что позволяет более точно разделять траектории в условиях перекрытия на основе более информативного дескриптора объекта.  
还要注意的是，SORT方法有一个基于深度学习的改进，称为Deep SORT。该改进基于为每个对象明确指定其描述符，这些描述符通过深度神经网络特征提取器对该对象所在区域进行处理，从而在重叠情况下基于更有信息量的对象描述符更准确地分离轨迹。

Tracking R-CNN построен на базе Mask R-CNN с добавлением трехмерных сверточных слоев для охвата временной составляющей между последовательностью кадров. Архитектуру Mask R-CNN мы рассматривали на одной из предыдущих лекций. Также данная архитектура имеет отдельную голову для дескрипторов объектов для ассоциации каждого результата детектирования с определенной траекторией. Tracktor++ предсказывает положение объекта на следующем кадре, вычисляя регрессию ограничивающей рамки без необходимости обучения или оптимизации данных отслеживания. Детектор объектов для Tracktor++ - это обычный Faster R-CNN со стандартной конфигурацией, обученной на наборе данных обнаружения пешеходов.  
Tracking R-CNN基于Mask R-CNN构建，增加了三维卷积层以涵盖帧序列之间的时间维度。我们在前一讲中讨论了Mask R-CNN的架构。该架构还具有一个单独的头部用于对象描述符，以将每个检测结果与特定轨迹关联起来。Tracktor++通过计算边框回归来预测对象在下一帧的位置，无需进行跟踪数据的训练或优化。Tracktor++的对象检测器是标准配置的Faster R-CNN，训练于行人检测数据集上。

JDE (Joint Detection and Embedding) использует Darknet-53 в качестве основы для получения карт характеристик входных данных в трех масштабах. После этого карты функций объединяются с использованием предискретизации и остаточных связей. Следует отметить, что данная сеть предлагает одновременное получение и результатов детектирования объектов, и соответствующих им embeddings. Она использует пирамидальную обработку при выделении признаков и специальные головы в нейросети, которые помимо bounding боксов и классов возвращают еще и дескриптор объекта, как показано на слайде.  
JDE（联合检测与嵌入）使用Darknet-53作为基础，在三个尺度上提取输入数据的特征图。然后，这些特征图通过预离散化和残差连接进行融合。需要注意的是，该网络同时提供对象检测结果及其嵌入（embeddings）。它在特征提取时使用金字塔处理，并在神经网络中使用特殊的头部，除了边框和类别，还返回对象的描述符，如幻灯片所示。

На этом лекция закончена. Спасибо за внимание.  
讲座到此结束。谢谢大家的关注。