# Rubiesh 1

- [Rubiesh 1](#rubiesh-1)
  - [Билет 1](#билет-1)
      - [1. Уровень бизнес-логики в программных системах зачем нужен, какую роль играет, как взаимодействует с другими уровнями.软件系统中为什么需要业务逻辑层，它扮演什么角色，它如何与其他层交互。](#1-уровень-бизнес-логики-в-программных-системах-зачем-нужен-какую-роль-играет-как-взаимодействует-с-другими-уровнями软件系统中为什么需要业务逻辑层它扮演什么角色它如何与其他层交互)
      - [2. Распределенные транзакции, спецификация XA分布式事务，XA 规范](#2-распределенные-транзакции-спецификация-xa分布式事务xa-规范)
      - [3. Диаграмма BPMN 2.0 для бизнес-процесса управления автомашина по продаже кофе (кофе-машина). Автомат должен уметь приготавливать несколько видов кофе, добавлять в кофе сливки и сахар и принимать к оплате наличные и карты и выдавать сдачу.管理咖啡自动售货机（咖啡机）的业务流程的 BPMN 2.0 图。该机器必须能够准备多种类型的咖啡、向咖啡中添加奶油和糖、接受现金和银行卡付款以及找零。](#3-диаграмма-bpmn-20-для-бизнес-процесса-управления-автомашина-по-продаже-кофе-кофе-машина-автомат-должен-уметь-приготавливать-несколько-видов-кофе-добавлять-в-кофе-сливки-и-сахар-и-принимать-к-оплате-наличные-и-карты-и-выдавать-сдачу管理咖啡自动售货机咖啡机的业务流程的-bpmn-20-图该机器必须能够准备多种类型的咖啡向咖啡中添加奶油和糖接受现金和银行卡付款以及找零)
  - [Билет 2](#билет-2)
      - [1. Spring Boot зачем нужен, как применяется, отличие от Spring обычного  为什么需要Spring Boot，如何使用，与普通Spring的区别](#1-spring-boot-зачем-нужен-как-применяется-отличие-от-spring-обычного--为什么需要spring-boot如何使用与普通spring的区别)
      - [2. Программное и декларативное выполнение транзакций в spring  Spring 中事务的编程式和声明式执行](#2-программное-и-декларативное-выполнение-транзакций-в-spring--spring-中事务的编程式和声明式执行)
    - [Spring 中事务的编程式和声明式执行](#spring-中事务的编程式和声明式执行)
      - [1. 编程式事务管理（Programmatic Transaction Management）](#1-编程式事务管理programmatic-transaction-management)
        - [编程式事务示例：](#编程式事务示例)
      - [2. 声明式事务管理（Declarative Transaction Management）](#2-声明式事务管理declarative-transaction-management)
        - [声明式事务示例：](#声明式事务示例)
      - [3. 编程式与声明式事务管理的对比](#3-编程式与声明式事务管理的对比)
      - [3. Нарисовать BPMN 2.0 диаграмму: 1 ноября и 1 апреля должны отчислять студентов у которых хотя бы одна Академ. задолженность. 画一张 BPMN 2.0 图：11 月 1 日和 4 月 1 日，至少有一项学术债务的学生必须被开除。](#3-нарисовать-bpmn-20-диаграмму-1-ноября-и-1-апреля-должны-отчислять-студентов-у-которых-хотя-бы-одна-академ-задолженность-画一张-bpmn-20-图11-月-1-日和-4-月-1-日至少有一项学术债务的学生必须被开除)
  - [Билет 3](#билет-3)
      - [1. BPMN и моделирование бизнес процессов.BPMN 和业务流程建模。](#1-bpmn-и-моделирование-бизнес-процессовbpmn-和业务流程建模)
      - [2. Политика безопасности в корпоративных приложения, зачем, за что отвечают, особенности реализации на уровне Бизнес-логики企业应用程序中的安全策略、原因、它们负责什么、业务逻辑级别的实现功能](#2-политика-безопасности-в-корпоративных-приложения-зачем-за-что-отвечают-особенности-реализации-на-уровне-бизнес-логики企业应用程序中的安全策略原因它们负责什么业务逻辑级别的实现功能)
      - [3. Написать класс, реализующий транзакцию, которая получает Почку, Seller и Buyer и совершает акт купли-продажи. Причем продавец не может суммарно продать, а покупатель купить более 2 почек.编写一个类，实现一个交易，该交易接收一个Kidney（肾）、Seller（卖家）和Buyer（买家），并执行买卖行为。卖家不能累计出售超过2个肾，买家也不能购买超过2个肾。](#3-написать-класс-реализующий-транзакцию-которая-получает-почку-seller-и-buyer-и-совершает-акт-купли-продажи-причем-продавец-не-может-суммарно-продать-а-покупатель-купить-более-2-почек编写一个类实现一个交易该交易接收一个kidney肾seller卖家和buyer买家并执行买卖行为卖家不能累计出售超过2个肾买家也不能购买超过2个肾)
  - [Билет 4](#билет-4)
      - [1. BPMN](#1-bpmn)
      - [2. Spring security (роли и т.д.)](#2-spring-security-роли-и-тд)
      - [3. Spring MVC rest. Штука, которая переводит деньги, и проверяет не превышен ли лимит переводов за месяц. Spring MVC 的 REST 接口：一个用于转账的功能，并检查当月的转账额度是否已超限。](#3-spring-mvc-rest-штука-которая-переводит-деньги-и-проверяет-не-превышен-ли-лимит-переводов-за-месяц-spring-mvc-的-rest-接口一个用于转账的功能并检查当月的转账额度是否已超限)
  - [Билет 5](#билет-5)
      - [1. Основные концепции использующиеся в разработке бизнес логики. 开发业务逻辑时使用的基本概念。](#1-основные-концепции-использующиеся-в-разработке-бизнес-логики-开发业务逻辑时使用的基本概念)
      - [2. Выполнение. Распределенные транзакции в Spring и Jakarta EE. 执行。 Spring 和 Jakarta EE 中的分布式事务。](#2-выполнение-распределенные-транзакции-в-spring-и-jakarta-ee-执行-spring-和-jakarta-ee-中的分布式事务)
      - [3. BPMN для управления ядерным реактором. Исключение несанкционированной ядерной реакции с помощью отрицательной обратной связи. (BPMN для ядерного реактора. Должен реализовывать аварийную остановку) 用于核反应堆控制的 BPMN。使用负反馈消除未经授权的核反应。 （核反应堆BPMN。应实施紧急停堆）](#3-bpmn-для-управления-ядерным-реактором-исключение-несанкционированной-ядерной-реакции-с-помощью-отрицательной-обратной-связи-bpmn-для-ядерного-реактора-должен-реализовывать-аварийную-остановку-用于核反应堆控制的-bpmn使用负反馈消除未经授权的核反应-核反应堆bpmn应实施紧急停堆)
  - [Билет 6](#билет-6)
      - [1. Описание bpmn 2.0. принципы построения, основные элементы.bpmn 2.0 的说明。构建原则、基本要素。](#1-описание-bpmn-20-принципы-построения-основные-элементыbpmn-20-的说明构建原则基本要素)
      - [2. Spring Security. Что, зачем, почему. Аннотации, файлы конфигурации.Spring Security，是什么，用处，为什么，注释，配置文件](#2-spring-security-что-зачем-почему-аннотации-файлы-конфигурацииspring-security是什么用处为什么注释配置文件)
      - [3. REST API для системы быстрых платежей с проверкой месячного ограничения переводов в 100 000 р用于快速支付系统的 REST API，可检查每月 100,000 卢布的转账限额](#3-rest-api-для-системы-быстрых-платежей-с-проверкой-месячного-ограничения-переводов-в-100-000-р用于快速支付系统的-rest-api可检查每月-100000-卢布的转账限额)
  - [Билет 7](#билет-7)
      - [1. Объекты потока-управления BPMN 2.0 BPMN 2.0 控制流对象](#1-объекты-потока-управления-bpmn-20-bpmn-20-控制流对象)
      - [2. JAAS (спизжено с конспекта) 2. JAAS](#2-jaas-спизжено-с-конспекта-2-jaas)
      - [3. Написать класс (валидатор) для автобуса, который позволяет покупать пассажиру билет. Деньги не списываются, если у человека недостаточно средств. Если человек уже оплатил и второй раз прикладывает карту, то средства не списываются. А также обнуляется билет по окончанию дня у данного пассажира.  为允许乘客购买车票的公共汽车编写一个类（验证器）。如果一个人没有足够的资金，钱不会被注销。如果一个人已经付款并再次申请该卡，则不会扣除资金。乘客的机票也会在当天结束时重置。](#3-написать-класс-валидатор-для-автобуса-который-позволяет-покупать-пассажиру-билет-деньги-не-списываются-если-у-человека-недостаточно-средств-если-человек-уже-оплатил-и-второй-раз-прикладывает-карту-то-средства-не-списываются-а-также-обнуляется-билет-по-окончанию-дня-у-данного-пассажира--为允许乘客购买车票的公共汽车编写一个类验证器如果一个人没有足够的资金钱不会被注销如果一个人已经付款并再次申请该卡则不会扣除资金乘客的机票也会在当天结束时重置)
- [Rubiesh 2](#rubiesh-2)
  - [Билет ?:](#билет-)
      - [1. Распределённая обработка в JMS (Jakarta Messaging)  JMS（Jakarta Messaging）中的分布式处理](#1-распределённая-обработка-в-jms-jakarta-messaging--jmsjakarta-messaging中的分布式处理)
      - [2. Bpms описание, плюсы, минусы  Bpm 描述、优点、缺点](#2-bpms-описание-плюсы-минусы--bpm-描述优点缺点)
      - [3. Написать планировщик, используя Java SE, который запускается каждый день в 00.00 и отправляет сообщения от студентов преподавателю, когда тот проверит рубежку. Во избежание ddos атаки интервал между сообщениями 5 секунд.  使用 Java SE 编写一个调度程序，每天 00:00 运行，并在老师检查里程碑时将学生的消息发送给老师。为了避免ddos攻击，消息之间的间隔为5秒。](#3-написать-планировщик-используя-java-se-который-запускается-каждый-день-в-0000-и-отправляет-сообщения-от-студентов-преподавателю-когда-тот-проверит-рубежку-во-избежание-ddos-атаки-интервал-между-сообщениями-5-секунд--使用-java-se-编写一个调度程序每天-0000-运行并在老师检查里程碑时将学生的消息发送给老师为了避免ddos攻击消息之间的间隔为5秒)
  - [Билет ?:](#билет--1)
      - [1. Active mq, архитектура, +/-, область применения  Active mq、架构、+/-、范围](#1-active-mq-архитектура---область-применения--active-mq架构-范围)
      - [2. Жизненный цикл BPM: фазы и что на них происходит  BPM 生命周期：各个阶段以及其中发生的情况](#2-жизненный-цикл-bpm-фазы-и-что-на-них-происходит--bpm-生命周期各个阶段以及其中发生的情况)
      - [3. С помощью jakarta ee сделать планировщик: Блокировать стулом дверь аудитории после 5 минут от начала пары, если лектор в аудитории и включил проектор и при этом в аудитории есть пара. Получить расписание можно по isu api.  使用 jakarta ee 制定计划：如果讲师在观众席中并且已打开投影仪并且观众席中有一对夫妇，则在课程开始 5 分钟后用椅子挡住教室门。您可以使用 isu api 获取时间表。](#3-с-помощью-jakarta-ee-сделать-планировщик-блокировать-стулом-дверь-аудитории-после-5-минут-от-начала-пары-если-лектор-в-аудитории-и-включил-проектор-и-при-этом-в-аудитории-есть-пара-получить-расписание-можно-по-isu-api--使用-jakarta-ee-制定计划如果讲师在观众席中并且已打开投影仪并且观众席中有一对夫妇则在课程开始-5-分钟后用椅子挡住教室门您可以使用-isu-api-获取时间表)
  - [Билет ?:](#билет--2)
      - [1. Протоколы их плюсы и минусы  协议及其优缺点](#1-протоколы-их-плюсы-и-минусы--协议及其优缺点)
      - [2. Основные компоненты jbms (Camunda?)  jbms的主要组件（Camunda？）](#2-основные-компоненты-jbms-camunda--jbms的主要组件camunda)
      - [3. Написать Quartz, который каждый день в 10 и 22 проверяет у пациентов температуру, если было уже в 2 раза превышение, то вызвать врачей для проведения теста ПЦР, если тест положительный, то ограничить пациента и всех, кто с ним контактировал на 10 дней, все методы для работы с врачами уже есть  写信给Quartz，每天10点和22点检查病人的体温，如果已经高了一倍，那就打电话给医生进行PCR检测，如果检测结果呈阳性，那就限制病人和所有接触过的人他呆了10天，仅此而已。已经有与医生合作的方法了](#3-написать-quartz-который-каждый-день-в-10-и-22-проверяет-у-пациентов-температуру-если-было-уже-в-2-раза-превышение-то-вызвать-врачей-для-проведения-теста-пцр-если-тест-положительный-то-ограничить-пациента-и-всех-кто-с-ним-контактировал-на-10-дней-все-методы-для-работы-с-врачами-уже-есть--写信给quartz每天10点和22点检查病人的体温如果已经高了一倍那就打电话给医生进行pcr检测如果检测结果呈阳性那就限制病人和所有接触过的人他呆了10天仅此而已已经有与医生合作的方法了)
  - [Билет 3:](#билет-3-1)
      - [1. Ресурсы и сообщения JMS  JMS 资源和消息](#1-ресурсы-и-сообщения-jms--jms-资源和消息)
      - [2. Установка и конфигурация jbpm (Camunda?)  jbpm 安装和配置（Camunda？）](#2-установка-и-конфигурация-jbpm-camunda--jbpm-安装和配置camunda)
      - [3. Планировщик на Spring: просыпается каждые 5 минут рабочего времени с 11:00 до 17:00 (по будням), исключая обеденные перерыв с 13:00 до 15:00 и выполняет:  春季调度程序：从 11:00 到 17:00（工作日），每 5 分钟工作时间唤醒一次，不包括 13:00 到 15:00 的午休时间，并执行：](#3-планировщик-на-spring-просыпается-каждые-5-минут-рабочего-времени-с-1100-до-1700-по-будням-исключая-обеденные-перерыв-с-1300-до-1500-и-выполняет--春季调度程序从-1100-到-1700工作日每-5-分钟工作时间唤醒一次不包括-1300-到-1500-的午休时间并执行)
  - [Билет 4:](#билет-4-1)
      - [1. Модели поставки сообщений в JMS  JMS 消息传递模型](#1-модели-поставки-сообщений-в-jms--jms-消息传递模型)
      - [2. Архитектура jBPM (Camunda)  jBPM 架构 (Camunda)](#2-архитектура-jbpm-camunda--jbpm-架构-camunda)
      - [3. Написать планировщик в cron, который каждый день в 5 утра кроме января, июля и августа будет запускать три скрипта  在 cron 中编写一个调度程序，除了一月、七月和八月之外，每天早上 5 点运行三个脚本](#3-написать-планировщик-в-cron-который-каждый-день-в-5-утра-кроме-января-июля-и-августа-будет-запускать-три-скрипта--在-cron-中编写一个调度程序除了一月七月和八月之外每天早上-5-点运行三个脚本)


## Билет 1

#### 1. Уровень бизнес-логики в программных системах зачем нужен, какую роль играет, как взаимодействует с другими уровнями.<br>软件系统中为什么需要业务逻辑层，它扮演什么角色，它如何与其他层交互。

Уровень бизнес-логики (Business Logic Layer, BLL) играет ключевую роль в программных системах, так как он отвечает за выполнение основных операций и правил, связанных с бизнесом или функциональностью приложения.  
业务逻辑层（Business Logic Layer, BLL）在软件系统中是一个非常重要的层级。它负责处理系统的核心功能和规则，确保数据在系统中的处理符合特定的业务需求。

1. Зачем нужен уровень бизнес-логики  
   为什么需要业务逻辑层  
   Основная причина существования уровня бизнес-логики — это изоляция и управление сложными бизнес-правилами и процессами, которые не должны находиться в интерфейсе пользователя или на уровне работы с базой данных.
   业务逻辑层的主要目的是将复杂的业务规则从表示层（UI）和数据访问层中分离出来，确保系统架构清晰、可维护。这种分离让系统具备更好的可扩展性和可测试性。

   - **Модульность и поддерживаемость**: Благодаря разделению логики можно изменять бизнес-правила без необходимости изменять интерфейс или работу с данными.  
     **模块化和可维护性**：通过将业务逻辑集中到一个独立的层，开发者可以更轻松地管理业务规则的变化，而不需要影响整个系统的其他部分。
   - **Снижение зависимости**: Уровень бизнес-логики снижает зависимость между интерфейсом пользователя (уровень представления) и уровнем данных, что облегчает тестирование и разработку.  
     **减少耦合**：业务逻辑层减少了表示层和数据访问层之间的耦合，使得前端和后端可以独立地进行开发和测试。
   - Повышение повторного использования: Логика, сосредоточенная на одном уровне, может быть использована повторно в различных интерфейсах, таких как веб-приложения и мобильные приложения.  
     **提高复用性**：业务逻辑可以被多个不同的表示层（例如Web端、移动端）所复用，避免重复开发。

2. **它扮演什么角色**
   Уровень бизнес-логики — это ядро системы, которое отвечает за выполнение бизнес-процессов, проверку данных и реализацию всех операций, связанных с бизнес-правилами:  
   业务逻辑层的核心角色是处理与业务相关的所有操作、规则和决策，它是系统中业务流程的中枢。它包括以下几个功能：

   - **Обработка бизнес-правил**: Уровень бизнес-логики проверяет правильность данных и применяет бизнес-правила, такие как лимиты на переводы денег в банковской системе.  
     **处理业务规则**：业务逻辑层应用系统的业务规则，确保数据的合法性和正确性。例如，银行系统中的业务逻辑可能会规定某个账户的转账金额不能超过一定的限额。  
   - **Выполнение бизнес-процессов**: В сложных системах этот уровень управляет выполнением последовательных шагов бизнес-процессов, обеспечивая их правильное выполнение.  
     **执行业务流程**：在复杂的系统中，业务逻辑层处理多个步骤的业务流程，确保这些步骤按照规定的顺序和条件执行。  
   - **Координация взаимодействия между уровнями**: Уровень бизнес-логики выступает связующим звеном между интерфейсом пользователя и уровнем данных, обеспечивая правильную обработку данных.  
     **协调其他层的交互**：业务逻辑层在一定程度上作为中介，协调表示层和数据访问层之间的交互，确保表示层展示的数据正确，数据访问层存储的数据符合业务规则。

3. **它如何与其他层交互**

   В архитектуре с разделением на три уровня, уровень бизнес-логики взаимодействует с уровнем представления и уровнем данных:  
   在三层架构中，业务逻辑层通常位于表示层和数据访问层之间。其主要作用是协调其他层的数据流动：

   - **Взаимодействие с уровнем представления**: Уровень представления (интерфейс пользователя) передает запросы от пользователя на уровень бизнес-логики, который обрабатывает их и возвращает результаты. Интерфейс не занимается логикой обработки данных напрямую.  
     **与表示层交互**：表示层负责用户界面交互，它将用户请求传递给业务逻辑层，业务逻辑层根据这些请求执行相应的操作并返回处理结果。表示层不直接处理数据，而是依赖业务逻辑层来执行具体的操作。
   - **Взаимодействие с уровнем данных**: Уровень бизнес-логики взаимодействует с базой данных через уровень доступа к данным (Data Access Layer), получая и передавая данные, а также гарантируя выполнение всех правил при изменении данных.  
     **与数据访问层交互**：业务逻辑层从数据访问层获取、处理数据，再将结果返回表示层。数据访问层的职责是与数据库或其他存储系统交互，而业务逻辑层确保这些数据符合业务规则，并做出相应的决策。

#### 2. Распределенные транзакции, спецификация XA<br>分布式事务，XA 规范

Распределённые транзакции (Distributed Transactions) — это способ координации выполнения одной транзакции между несколькими независимыми системами или ресурсами, такими как базы данных, очереди сообщений и другие хранилища данных.  
分布式事务（Distributed Transaction）是指在多个独立的资源管理器（如多个数据库、消息队列等）之间协调执行的事务。由于这些资源可能位于不同的节点上，因此需要一个机制来保证这些资源的一致性，确保事务要么在所有资源上成功提交，要么全部回滚。这就是分布式事务要解决的问题。

1. Что такое распределенные транзакции?  
   分布式事务是什么？  

   Распределенные транзакции обеспечивают согласованность данных между несколькими ресурсами в распределенной системе. Это необходимо, когда одна транзакция затрагивает несколько независимых систем, и нужно гарантировать, что все операции будут выполнены или отменены как единое целое (ACID-принципы).  
   分布式事务是为了保证多个系统之间的数据一致性而设计的，它确保了在一个复杂的分布式环境中，数据操作可以像本地事务一样进行原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability），即ACID特性。

   Основной механизм координации распределенных транзакций — это протокол двухфазной фиксации (Two-Phase Commit, 2PC):  
   分布式事务通过**两阶段提交协议（Two-Phase Commit, 2PC）**来协调多个节点的操作：

   - **Первая фаза: подготовка (Prepare)**: Координатор транзакции (Transaction Manager) отправляет всем участникам запрос на подготовку к фиксации. Если все ресурсы готовы, то переходит ко второй фазе.  
     **第一阶段：准备（Prepare）**：事务管理器向所有参与的资源管理器发送准备请求，询问它们是否可以提交该事务。如果所有资源管理器都返回准备成功，则事务管理器进入第二阶段。
   - **Вторая фаза: фиксация или откат (Commit/Rollback)**: Если все участники готовы, координатор отправляет команду фиксации, в противном случае — откат.  
     **第二阶段：提交（Commit）或回滚（Rollback）**：如果所有资源管理器都同意提交，事务管理器发送提交命令；否则，发送回滚命令，撤销事务。
2. **Что такое спецификация XA?**  
   **XA规范是什么？**

   XA — это стандарт распределенной обработки транзакций, разработанный Open Group. Он описывает интерфейсы взаимодействия между менеджером транзакций (Transaction Manager, TM) и менеджером ресурсов (Resource Manager, RM). Спецификация XA позволяет менеджеру транзакций координировать выполнение транзакции между несколькими ресурсами.  
   XA（Extended Architecture for Distributed Transaction Processing）是由开放组（Open Group）提出的一种分布式事务处理规范，它定义了事务管理器（Transaction Manager, TM）和资源管理器（Resource Manager, RM）之间的接口。XA规范帮助协调不同系统之间的事务处理，确保跨多个资源管理器的操作能够保持一致性。

   - Менеджер транзакций (TM): Координирует выполнение транзакции, управляет процессом двухфазной фиксации и отвечает за согласованность.  
     事务管理器（TM）：事务管理器负责协调整个分布式事务。它发送准备、提交或回滚的请求，并确保所有参与者能够在事务的一致性上达成共识。  
   - Менеджер ресурсов (RM): Управляет доступом к данным и отвечает за выполнение команд фиксации или отката транзакции, получаемых от TM через интерфейс XA.  
     资源管理器（RM）：资源管理器是持久性存储系统（如数据库、消息队列）的一部分，负责管理事务中的具体资源。它通过XA接口与事务管理器通信，响应提交或回滚请求。
3. **Реализация распределенных транзакций и XA**  
   **分布式事务与XA的实现**
   - **Реализация менеджера транзакций**: Инструменты, такие как Bitronix, Atomikos и Narayana, реализуют спецификацию XA и координируют транзакции между различными ресурсами.  
     **事务管理器实现**：像Bitronix、Atomikos、Narayana等都是实现了XA规范的事务管理器，它们负责协调分布式系统中的不同资源管理器，以保证事务的一致性。  
   - **Реализация менеджера ресурсов**: Большинство современных баз данных и систем сообщений, таких как MySQL, PostgreSQL, Oracle, ActiveMQ, поддерживают спецификацию XA и могут участвовать в распределенных транзакциях как менеджеры ресурсов.  
     **资源管理器实现**：大多数现代的数据库和消息队列（如MySQL、PostgreSQL、Oracle、ActiveMQ、RabbitMQ）都支持XA协议，能够作为资源管理器参与到分布式事务中。

#### 3. Диаграмма BPMN 2.0 для бизнес-процесса управления автомашина по продаже кофе (кофе-машина). Автомат должен уметь приготавливать несколько видов кофе, добавлять в кофе сливки и сахар и принимать к оплате наличные и карты и выдавать сдачу.<br>管理咖啡自动售货机（咖啡机）的业务流程的 BPMN 2.0 图。该机器必须能够准备多种类型的咖啡、向咖啡中添加奶油和糖、接受现金和银行卡付款以及找零。

[https://drive.google.com/file/d/1FcBR5zZ-QivXPxe4VO8fiK0eQmv7iv9E/view?usD=sharing](https://drive.google.com/file/d/1FcBR5zZ-QivXPxe4VO8fiK0eOmy7iy9E/view?usp=sharing)
можете исправлять если что, я хз, как это адекватно сделать

## Билет 2

#### 1. Spring Boot зачем нужен, как применяется, отличие от Spring обычного <br> 为什么需要Spring Boot，如何使用，与普通Spring的区别

1. **Зачем нужен Spring Boot  **
   **为什么需要Spring Boot**

   Spring Boot создан для упрощения разработки с использованием фреймворка Spring. Основная задача — сократить время и усилия, необходимые для создания приложения на Spring, устранив сложную ручную настройку и конфигурацию.  
   Spring Boot 是基于 Spring 框架的一个快速开发框架，旨在简化 Spring 应用程序的开发。它解决了传统 Spring 项目开发中的复杂配置问题，使开发者能够更快地构建和部署应用程序。

   1. **Упрощенная конфигурация**: В обычных Spring-приложениях разработчики сталкиваются с необходимостью настраивать множество компонентов вручную с использованием XML или аннотаций. Spring Boot использует механизм автоконфигурации (Auto Configuration), которая автоматически настраивает компоненты, минимизируя необходимость в ручной настройке.  
      **简化配置**：传统的 Spring 框架项目需要开发者手动编写大量的 XML 配置文件或注解来管理依赖注入、事务管理、安全配置等。Spring Boot 通过自动配置（Auto Configuration）和预先设定的默认配置，减少了开发者的配置负担。开发者只需要关注业务逻辑，而不是大量的框架配置。

   2. **Встроенные серверы**: Spring Boot включает в себя встроенные веб-серверы, такие как Tomcat и Jetty, что позволяет запускать приложение как обычное Java-приложение, без необходимости настройки внешнего сервера.  
      嵌入式服务器：Spring Boot 提供嵌入式的 Tomcat、Jetty 等 Web 服务器，使得开发者可以直接在应用中启动和运行服务器，而不需要像传统 Spring 项目那样单独部署到外部服务器。这使得应用程序的部署更加简单，也适合于云环境和容器化（如 Docker）部署。

   3. **Быстрое развертывание**: Spring Boot предлагает так называемые стартеры (Starters) — предварительно сконфигурированные наборы зависимостей для различных функций, например, для веб-приложений, доступа к данным, безопасности и т. д. Это позволяет разработчику начать работу намного быстрее.  
      **快速启动**：Spring Boot 提供了启动器依赖（Starters），例如 spring-boot-starter-web、spring-boot-starter-data-jpa 等，开发者只需引入这些启动器依赖，就能快速集成常用功能，而不需要单独引入各种依赖和配置它们。

   4. Управление и мониторинг: Spring Boot интегрирует Spring Actuator, который предоставляет готовые средства для мониторинга и управления приложением, такие как метрики, проверка состояния, информация о сессиях и многое другое.  
      简化监控和管理：Spring Boot 集成了 Spring Actuator，它为应用程序提供了健康检查、指标收集、日志记录等监控功能，方便开发者对应用的运行状态进行管理。

2. Как применяется Spring Boot  
   **如何使用 Spring Boot**
   Для использования Spring Boot достаточно выполнить несколько шагов:
   使用 Spring Boot 的开发过程非常简单，主要包括以下步骤：

   1. **Создание проекта**: Можно воспользоваться Spring Initializr для генерации базового проекта.  
      **创建项目**：可以通过 Spring Initializr（https://start.spring.io）快速创建 Spring Boot 项目，选择所需的依赖。

   2. **Главный класс**: Главный класс с аннотацией @SpringBootApplication и методом main запускает приложение:  
      **启动类**：在主类中添加 @SpringBootApplication 注解，并通过 main 方法启动应用程序。例如：

      ```java
      @SpringBootApplication
      public class MyApplication {
          public static void main(String[] args) {
              SpringApplication.run(MyApplication.class, args);
          }
      }
      ```
   3. **Автоконфигурация**: В зависимости от подключенных зависимостей Spring Boot автоматически настраивает необходимые компоненты.  
      **自动配置**：Spring Boot 会根据添加的依赖和配置自动加载所需的 Bean 和服务。例如，添加 spring-boot-starter-web 依赖后，应用程序会自动配置 Web 服务。

   4. **Разработка приложения**: После этого можно приступать к созданию REST-контроллеров, сервисов и других компонентов с использованием Spring.  
      **应用开发**：在此基础上，开发者可以使用 Spring 的注解如 @RestController、@Service 等，定义控制器、服务和业务逻辑。

3. **Отличие от обычного Spring**  
   **与普通Spring的区别**

   Основные различия между Spring Boot и обычным Spring заключаются в следующем:  
   Spring Boot 和传统的 Spring 框架在功能和开发体验上存在一些显著的区别：

   1. **Конфигурация 配置方式**：
      - Spring: В традиционном Spring много ручной настройки через XML или аннотации.  
        Spring：传统的 Spring 项目需要大量的手动配置，通常使用 XML 文件或注解来定义 Bean、事务管理、数据源等。
      - Spring Boot: Автоконфигурация уменьшает количество ручных настроек.  
        Spring Boot：Spring Boot 提供了自动配置，大多数配置项都有合理的默认值，开发者可以选择性地覆盖部分配置，而无需手动定义大量配置。
   2. **Управление зависимостями 依赖管理**：
      - Spring: Разработчики самостоятельно добавляют зависимости и следят за совместимостью версий.  
        Spring：在普通 Spring 项目中，开发者需要手动引入所需的依赖，并确保不同依赖版本之间的兼容性。
      - Spring Boot: Стартеры включают все необходимые зависимости, что упрощает конфигурацию.  
        Spring Boot：Spring Boot 提供了一系列启动器（Starters），这些启动器将常用的依赖打包在一起，简化了依赖管理。例如，spring-boot-starter-data-jpa 包含了 JPA、Hibernate、数据源驱动等常用依赖。
   3. **Настройка серверов 服务器配置**
      - Spring: Необходимо настраивать и развертывать внешние серверы приложений, такие как Tomcat.  
        Spring：传统 Spring 项目需要手动配置和部署到外部应用服务器（如 Tomcat）。
      - Spring Boot: Приложения могут запускаться на встроенных серверах без внешней настройки.  
        Spring Boot：Spring Boot 提供嵌入式的 Tomcat、Jetty 等服务器，应用程序可以打包为可执行的 JAR 文件，直接运行，无需单独配置服务器。
   4. **Эффективность разработки 开发效率**
      - Spring: Проекты на обычном Spring требуют больше времени на настройку и запуск.  
        Spring：传统的 Spring 项目启动时间较长，配置复杂，开发者需要投入较多精力进行环境配置。
      - Spring Boot: Проекты запускаются быстрее и проще в настройке, что значительно увеличивает производительность разработки.  
        Spring Boot：Spring Boot 提供了很多开箱即用的功能，通过简化配置、嵌入式服务器和自动配置，使得开发、测试、部署更加快速和高效。

#### 2. Программное и декларативное выполнение транзакций в spring <br> Spring 中事务的编程式和声明式执行

在 Spring 框架中，事务管理是一个非常重要的功能，用于确保数据的一致性和完整性。Spring 提供了两种处理事务的方式：编程式事务管理（Programmatic Transaction Management） 和 声明式事务管理（Declarative Transaction Management）。它们在使用场景和实现方式上有着显著的区别。

1. 编程式事务管理（Programmatic Transaction Management）
编程式事务管理要求开发者手动管理事务的开始、提交和回滚。这种方式虽然提供了对事务的细粒度控制，但也增加了代码的复杂性，因为开发者必须显式地处理每个事务的生命周期。

   - 优点: 灵活性高，适合复杂的事务场景，可以对事务的每个细节进行控制。
   - 缺点: 代码冗长，难以维护。开发者必须确保在出现异常时正确处理事务的回滚。
   
    ```java   
    public class MyService {

        @Autowired
        private PlatformTransactionManager transactionManager;

        public void performOperation() {
            // 获取事务定义
            DefaultTransactionDefinition def = new DefaultTransactionDefinition();
            TransactionStatus status = transactionManager.getTransaction(def);

            try {
                // 业务逻辑
                someDatabaseOperation();

                // 提交事务
                transactionManager.commit(status);
            } catch (Exception e) {
                // 事务回滚
                transactionManager.rollback(status);
                throw e;
            }
        }
    }
    ```
   在这个例子中，开发者手动控制事务的开始、提交和回滚。PlatformTransactionManager 提供了对事务的直接控制，transactionManager.getTransaction() 用于开始事务，transactionManager.commit() 提交事务，而 transactionManager.rollback() 在出现异常时回滚事务。

2. 声明式事务管理（Declarative Transaction Management）

   声明式事务管理不需要显式地在代码中管理事务，而是通过注解或 XML 配置来定义事务的边界。Spring AOP（面向切面编程）会自动在方法执行前后处理事务的开启、提交和回滚。开发者只需要在适当的地方使用注解，框架会自动管理事务。

   - 优点: 简洁、易于维护，减少了开发者手动管理事务的负担，减少了代码的复杂度。
   - 缺点: 灵活性不如编程式事务管理，但对于大多数场景已经足够。

    ```java
    @Service
    public class MyService {

        @Transactional
        public void performOperation() {
            // 业务逻辑
            someDatabaseOperation();
        }
    }
    ```

    在这个例子中，@Transactional 注解用于声明该方法是事务性的。Spring 在方法执行前会自动开启事务，方法执行后根据情况自动提交或回滚事务。这大大简化了事务管理的工作，使得代码更加简洁。

### Spring 中事务的编程式和声明式执行

在 Spring 框架中，事务管理是一个非常重要的功能，用于确保数据的一致性和完整性。Spring 提供了两种处理事务的方式：**编程式事务管理（Programmatic Transaction Management）** 和 **声明式事务管理（Declarative Transaction Management）**。它们在使用场景和实现方式上有着显著的区别。

#### 1. 编程式事务管理（Programmatic Transaction Management）

编程式事务管理要求开发者手动管理事务的开始、提交和回滚。这种方式虽然提供了对事务的细粒度控制，但也增加了代码的复杂性，因为开发者必须显式地处理每个事务的生命周期。

- **优点**: 灵活性高，适合复杂的事务场景，可以对事务的每个细节进行控制。
- **缺点**: 代码冗长，难以维护。开发者必须确保在出现异常时正确处理事务的回滚。

##### 编程式事务示例：
```java
public class MyService {

    @Autowired
    private PlatformTransactionManager transactionManager;

    public void performOperation() {
        // 获取事务定义
        DefaultTransactionDefinition def = new DefaultTransactionDefinition();
        TransactionStatus status = transactionManager.getTransaction(def);

        try {
            // 业务逻辑
            someDatabaseOperation();

            // 提交事务
            transactionManager.commit(status);
        } catch (Exception e) {
            // 事务回滚
            transactionManager.rollback(status);
            throw e;
        }
    }
}
```
在这个例子中，开发者手动控制事务的开始、提交和回滚。`PlatformTransactionManager` 提供了对事务的直接控制，`transactionManager.getTransaction()` 用于开始事务，`transactionManager.commit()` 提交事务，而 `transactionManager.rollback()` 在出现异常时回滚事务。

#### 2. 声明式事务管理（Declarative Transaction Management）

声明式事务管理不需要显式地在代码中管理事务，而是通过注解或 XML 配置来定义事务的边界。Spring AOP（面向切面编程）会自动在方法执行前后处理事务的开启、提交和回滚。开发者只需要在适当的地方使用注解，框架会自动管理事务。

- **优点**: 简洁、易于维护，减少了开发者手动管理事务的负担，减少了代码的复杂度。
- **缺点**: 灵活性不如编程式事务管理，但对于大多数场景已经足够。

##### 声明式事务示例：
```java
@Service
public class MyService {

    @Transactional
    public void performOperation() {
        // 业务逻辑
        someDatabaseOperation();
    }
}
```
在这个例子中，`@Transactional` 注解用于声明该方法是事务性的。Spring 在方法执行前会自动开启事务，方法执行后根据情况自动提交或回滚事务。这大大简化了事务管理的工作，使得代码更加简洁。

#### 3. 编程式与声明式事务管理的对比

| 对比项                 | 编程式事务管理                         | 声明式事务管理                      |
|------------------------|----------------------------------------|------------------------------------|
| **灵活性**             | 高，开发者可以手动控制每个事务的生命周期 | 较低，事务边界由框架自动管理        |
| **代码复杂度**         | 高，需要显式处理事务的启动、提交和回滚  | 低，只需使用注解或配置文件声明事务 |
| **维护性**             | 难以维护，代码冗长                     | 容易维护，代码更加简洁              |
| **适用场景**           | 复杂事务处理，或者需要高度定制的场景     | 常见的事务处理场景                  |

| Параметр               | Программное управление          | Декларативное управление          |
|------------------------|-------------------------------|----------------------------------|
| **Гибкость**            | Высокая                       | Низкая                           |
| **Сложность кода**      | Более сложный код              | Код проще и понятнее              |
| **Поддержка и масштабируемость** | Труднее поддерживать        | Легче поддерживать               |
| **Применение**          | Для сложных и кастомных задач  | Для стандартных транзакционных операций |

#### 3. Нарисовать BPMN 2.0 диаграмму: 1 ноября и 1 апреля должны отчислять студентов у которых хотя бы одна Академ. задолженность. <br>画一张 BPMN 2.0 图：11 月 1 日和 4 月 1 日，至少有一项学术债务的学生必须被开除。

## Билет 3

#### 1. BPMN и моделирование бизнес процессов.<br>BPMN 和业务流程建模。

#### 2. Политика безопасности в корпоративных приложения, зачем, за что отвечают, особенности реализации на уровне Бизнес-логики<br>企业应用程序中的安全策略、原因、它们负责什么、业务逻辑级别的实现功能

#### 3. Написать класс, реализующий транзакцию, которая получает Почку, Seller и Buyer и совершает акт купли-продажи. Причем продавец не может суммарно продать, а покупатель купить более 2 почек.<br>编写一个类，实现一个交易，该交易接收一个Kidney（肾）、Seller（卖家）和Buyer（买家），并执行买卖行为。卖家不能累计出售超过2个肾，买家也不能购买超过2个肾。

## Билет 4

#### 1. BPMN

#### 2. Spring security (роли и т.д.)

#### 3. Spring MVC rest. Штука, которая переводит деньги, и проверяет не превышен ли лимит переводов за месяц. <br>Spring MVC 的 REST 接口：一个用于转账的功能，并检查当月的转账额度是否已超限。

## Билет 5

#### 1. Основные концепции использующиеся в разработке бизнес логики. <br>开发业务逻辑时使用的基本概念。

#### 2. Выполнение. Распределенные транзакции в Spring и Jakarta EE. <br>执行。 Spring 和 Jakarta EE 中的分布式事务。

#### 3. BPMN для управления ядерным реактором. Исключение несанкционированной ядерной реакции с помощью отрицательной обратной связи. (BPMN для ядерного реактора. Должен реализовывать аварийную остановку) <br>用于核反应堆控制的 BPMN。使用负反馈消除未经授权的核反应。 （核反应堆BPMN。应实施紧急停堆）

## Билет 6

#### 1. Описание bpmn 2.0. принципы построения, основные элементы.<br>bpmn 2.0 的说明。构建原则、基本要素。

#### 2. Spring Security. Что, зачем, почему. Аннотации, файлы конфигурации.<br>Spring Security，是什么，用处，为什么，注释，配置文件

#### 3. REST API для системы быстрых платежей с проверкой месячного ограничения переводов в 100 000 р<br>用于快速支付系统的 REST API，可检查每月 100,000 卢布的转账限额

## Билет 7

#### 1. Объекты потока-управления BPMN 2.0 <br>BPMN 2.0 控制流对象

#### 2. JAAS (спизжено с конспекта) <br>2. JAAS

#### 3. Написать класс (валидатор) для автобуса, который позволяет покупать пассажиру билет. Деньги не списываются, если у человека недостаточно средств. Если человек уже оплатил и второй раз прикладывает карту, то средства не списываются. А также обнуляется билет по окончанию дня у данного пассажира. <br> 为允许乘客购买车票的公共汽车编写一个类（验证器）。如果一个人没有足够的资金，钱不会被注销。如果一个人已经付款并再次申请该卡，则不会扣除资金。乘客的机票也会在当天结束时重置。

# Rubiesh 2

## Билет ?:

#### 1. Распределённая обработка в JMS (Jakarta Messaging) <br> JMS（Jakarta Messaging）中的分布式处理

#### 2. Bpms описание, плюсы, минусы <br> Bpm 描述、优点、缺点

#### 3. Написать планировщик, используя Java SE, который запускается каждый день в 00.00 и отправляет сообщения от студентов преподавателю, когда тот проверит рубежку. Во избежание ddos атаки интервал между сообщениями 5 секунд. <br> 使用 Java SE 编写一个调度程序，每天 00:00 运行，并在老师检查里程碑时将学生的消息发送给老师。为了避免ddos攻击，消息之间的间隔为5秒。

## Билет ?:

#### 1. Active mq, архитектура, +/-, область применения <br> Active mq、架构、+/-、范围

#### 2. Жизненный цикл BPM: фазы и что на них происходит <br> BPM 生命周期：各个阶段以及其中发生的情况

#### 3. С помощью jakarta ee сделать планировщик: Блокировать стулом дверь аудитории после 5 минут от начала пары, если лектор в аудитории и включил проектор и при этом в аудитории есть пара. Получить расписание можно по isu api. <br> 使用 jakarta ee 制定计划：如果讲师在观众席中并且已打开投影仪并且观众席中有一对夫妇，则在课程开始 5 分钟后用椅子挡住教室门。您可以使用 isu api 获取时间表。

## Билет ?:

#### 1. Протоколы их плюсы и минусы <br> 协议及其优缺点

#### 2. Основные компоненты jbms (Camunda?) <br> jbms的主要组件（Camunda？）

#### 3. Написать Quartz, который каждый день в 10 и 22 проверяет у пациентов температуру, если было уже в 2 раза превышение, то вызвать врачей для проведения теста ПЦР, если тест положительный, то ограничить пациента и всех, кто с ним контактировал на 10 дней, все методы для работы с врачами уже есть <br> 写信给Quartz，每天10点和22点检查病人的体温，如果已经高了一倍，那就打电话给医生进行PCR检测，如果检测结果呈阳性，那就限制病人和所有接触过的人他呆了10天，仅此而已。已经有与医生合作的方法了

## Билет 3:

#### 1. Ресурсы и сообщения JMS <br> JMS 资源和消息

#### 2. Установка и конфигурация jbpm (Camunda?) <br> jbpm 安装和配置（Camunda？）

#### 3. Планировщик на Spring: просыпается каждые 5 минут рабочего времени с 11:00 до 17:00 (по будням), исключая обеденные перерыв с 13:00 до 15:00 и выполняет: <br> 春季调度程序：从 11:00 到 17:00（工作日），每 5 分钟工作时间唤醒一次，不包括 13:00 到 15:00 的午休时间，并执行：

## Билет 4:

#### 1. Модели поставки сообщений в JMS <br> JMS 消息传递模型

#### 2. Архитектура jBPM (Camunda) <br> jBPM 架构 (Camunda)

#### 3. Написать планировщик в cron, который каждый день в 5 утра кроме января, июля и августа будет запускать три скрипта <br> 在 cron 中编写一个调度程序，除了一月、七月和八月之外，每天早上 5 点运行三个脚本

