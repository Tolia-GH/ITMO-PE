## [MainPage](../index.md)/[SOA](./README.md)/Rubiesh 2

- [MainPage/SOA/Rubiesh 2](#mainpagesoarubiesh-2)
  - [Вариант 1](#вариант-1)
    - [1. Варианты реализации Service Discovery  服务发现实现方式](#1-варианты-реализации-service-discovery--服务发现实现方式)
    - [2. Структура реестра UDDI  UDDI 注册中心结构](#2-структура-реестра-uddi--uddi-注册中心结构)
    - [3. Сервис на JAX-WS реализующий DNS  实现 DNS 的 JAX-WS 服务](#3-сервис-на-jax-ws-реализующий-dns--实现-dns-的-jax-ws-服务)
  - [Вариант 2](#вариант-2)
    - [1. Service Discovery на Java EE и его реализации  Java EE 中的服务发现及其实现](#1-service-discovery-на-java-ee-и-его-реализации--java-ee-中的服务发现及其实现)
    - [2. Понятие микросервиса. Отличия и сходства от других сервисов.  微服务的概念。与其他服务的区别和相似之处。](#2-понятие-микросервиса-отличия-и-сходства-от-других-сервисов--微服务的概念与其他服务的区别和相似之处)
    - [3. Написать двухтарифный счётчик электроэнергии для интеграции его в ИС-предприятия на JAX-WS  编写双费率电表，以便将其集成到 JAX-WS 上的企业信息系统中](#3-написать-двухтарифный-счётчик-электроэнергии-для-интеграции-его-в-ис-предприятия-на-jax-ws--编写双费率电表以便将其集成到-jax-ws-上的企业信息系统中)
  - [Вариант 3](#вариант-3)
    - [1. Концепция Service Discovery.  服务发现的概念。](#1-концепция-service-discovery--服务发现的概念)
    - [2. Smart endpoints \& Dumb pipes в МСА.  微服务架构中的“智能端点\&愚蠢管道”](#2-smart-endpoints--dumb-pipes-в-мса--微服务架构中的智能端点愚蠢管道)
    - [3. Сервис Jax-ws по менеджменту учащихся.  Jax-ws 学生管理服务。](#3-сервис-jax-ws-по-менеджменту-учащихся--jax-ws-学生管理服务)
  - [Вариант 4](#вариант-4)
    - [1. Service Discovery в решениях на базе Spring Cloud Netflix  Spring Cloud Netflix 解决方案中的服务发现](#1-service-discovery-в-решениях-на-базе-spring-cloud-netflix--spring-cloud-netflix-解决方案中的服务发现)
    - [2. Технология JAX-WS и её использование для реализации веб-сервисов  JAX-WS 技术及其在实现 Web 服务中的应用](#2-технология-jax-ws-и-её-использование-для-реализации-веб-сервисов--jax-ws-技术及其在实现-web-服务中的应用)
    - [3. Набор микросервисов на Spring MVC, управляющий распределением по аудиториям и преподавателям студентов, ожидающих своей очереди на доп. Должна поддерживаться возможность добавления новых аудиторий и преподавателей и удаления существующих. В одной аудитории может находиться более одного преподавателя.  一组基于 Spring MVC 的微服务，用于管理排队等待加课的学生在教室和老师之间的分配。应该可以添加新的教室和教师，并删除现有的教室和教师。一个教室可能有多个老师。](#3-набор-микросервисов-на-spring-mvc-управляющий-распределением-по-аудиториям-и-преподавателям-студентов-ожидающих-своей-очереди-на-доп-должна-поддерживаться-возможность-добавления-новых-аудиторий-и-преподавателей-и-удаления-существующих-в-одной-аудитории-может-находиться-более-одного-преподавателя--一组基于-spring-mvc-的微服务用于管理排队等待加课的学生在教室和老师之间的分配应该可以添加新的教室和教师并删除现有的教室和教师一个教室可能有多个老师)
  - [Вариант 5](#вариант-5)
    - [1. Реализация микросервисов на Spring Cloud.  Spring Cloud 上的微服务的实现。](#1-реализация-микросервисов-на-spring-cloud--spring-cloud-上的微服务的实现)
    - [2. Service Discovery и Service Registry.](#2-service-discovery-и-service-registry)
    - [3. Веб-сервис на JAX-WS, управляющий процессом выпечки колобков. Выпечка пирожка состоит из последовательности взаимозависимых этапов, выполнение которых должен обеспечивать сервис - поскребание по сусекам, подготовка теста, лепка заготовки, термическая обработка.  管理烘焙 kolobok 过程的 JAX-WS Web 服务。烘烤馅饼包括一系列相互依赖的阶段，服务必须确保这些阶段的实施 - 刮擦桶底，准备面团，塑造坯料，热处理。](#3-веб-сервис-на-jax-ws-управляющий-процессом-выпечки-колобков-выпечка-пирожка-состоит-из-последовательности-взаимозависимых-этапов-выполнение-которых-должен-обеспечивать-сервис---поскребание-по-сусекам-подготовка-теста-лепка-заготовки-термическая-обработка--管理烘焙-kolobok-过程的-jax-ws-web-服务烘烤馅饼包括一系列相互依赖的阶段服务必须确保这些阶段的实施---刮擦桶底准备面团塑造坯料热处理)
  - [Вариант 6](#вариант-6)
    - [1. Реализация Service Discovery на уровне инфраструктурного ПО  在基础设施软件层面实现服务发现](#1-реализация-service-discovery-на-уровне-инфраструктурного-по--在基础设施软件层面实现服务发现)
    - [2. Реализация микросервисов на Java EE  在 Java EE 上实现微服务](#2-реализация-микросервисов-на-java-ee--在-java-ee-上实现微服务)
    - [3. Конфигурация в Consul сервиса по выпеканию пирожков с пулом экземпляров сервиса. Сервис реализован на Jakarta EE и развернут в контейнере приложений Wildfly на серверах helios, terra и aqua  在 Consul 中配置带有服务实例池的馅饼烘焙服务。该服务在 Jakarta EE 上实现，并部署在 helios、terra 和 aqua 服务器上的 Wildfly 应用程序容器中](#3-конфигурация-в-consul-сервиса-по-выпеканию-пирожков-с-пулом-экземпляров-сервиса-сервис-реализован-на-jakarta-ee-и-развернут-в-контейнере-приложений-wildfly-на-серверах-helios-terra-и-aqua--在-consul-中配置带有服务实例池的馅饼烘焙服务该服务在-jakarta-ee-上实现并部署在-heliosterra-和-aqua-服务器上的-wildfly-应用程序容器中)
  - [Вариант 7](#вариант-7)
    - [1. Consul. Назначение, архитектура, возможности  Consul：目的、架构、功能](#1-consul-назначение-архитектура-возможности--consul目的架构功能)
    - [2. Микросервисы на spring boot  Spring Boot 上的微服务](#2-микросервисы-на-spring-boot--spring-boot-上的微服务)
    - [3. Написать на JAX-WS сервис по управлению процессом изготовления резиновых уточек](#3-написать-на-jax-ws-сервис-по-управлению-процессом-изготовления-резиновых-уточек)
  - [Вариант 8](#вариант-8)
    - [1. Service Discovery](#1-service-discovery)
    - [2. Smart Endpoints \& Dump pipes](#2-smart-endpoints--dump-pipes)
    - [3. Jax-ws сервис по управлению контингентом в университете](#3-jax-ws-сервис-по-управлению-контингентом-в-университете)
  - [Вариант 9](#вариант-9)
    - [1. Основные проблема коммуникации микросервисов и способы их решения](#1-основные-проблема-коммуникации-микросервисов-и-способы-их-решения)
    - [2. Circuit Breaker. Принципы, реализация, примеры использования.](#2-circuit-breaker-принципы-реализация-примеры-использования)
    - [3. JAX-WS сервис по управлению авиаперелётами](#3-jax-ws-сервис-по-управлению-авиаперелётами)
  - [Вариант 10](#вариант-10)
    - [1. Load Balancer в Spring Cloud.](#1-load-balancer-в-spring-cloud)
    - [2. Mule ESB, основные свойства и понятия.](#2-mule-esb-основные-свойства-и-понятия)
    - [3. Конфигурация на Consul пула серверов WildFly, на которых развёрнута Jakarta EE система по выпеканию пирожков.](#3-конфигурация-на-consul-пула-серверов-wildfly-на-которых-развёрнута-jakarta-ee-система-по-выпеканию-пирожков)
  - [Вариант 11](#вариант-11)
    - [1. Оркестровка и хореография микросервисов](#1-оркестровка-и-хореография-микросервисов)
    - [2. Top-down и bottom-up стратегии при использовании аннотаций wsdl](#2-top-down-и-bottom-up-стратегии-при-использовании-аннотаций-wsdl)
    - [3. Конфигурация Spring Boot сервиса для подключения Consul, он живет на localhost на 8500 порту](#3-конфигурация-spring-boot-сервиса-для-подключения-consul-он-живет-на-localhost-на-8500-порту)
  - [Вариант 12](#вариант-12)
    - [1. Свойства и ключевые особенности микросервиса.](#1-свойства-и-ключевые-особенности-микросервиса)
    - [2. Структура документа WSDL](#2-структура-документа-wsdl)
    - [3. Конфигурация, регистрирующая в Consul пул экземпляров СУБД MySQL. Сервисы расположены на машинах ra, helios и anubis, экземпляры занимают порт 3306 на каждой из машин. Конфигурация должна обеспечивать проверку того, запущены ли экземпляры каждого из сервисов.](#3-конфигурация-регистрирующая-в-consul-пул-экземпляров-субд-mysql-сервисы-расположены-на-машинах-ra-helios-и-anubis-экземпляры-занимают-порт-3306-на-каждой-из-машин-конфигурация-должна-обеспечивать-проверку-того-запущены-ли-экземпляры-каждого-из-сервисов)
  - [Вариант 13](#вариант-13)
    - [1. Преимущества и недостатки MSA по сравнению с “обычной” SOA.](#1-преимущества-и-недостатки-msa-по-сравнению-с-обычной-soa)
    - [2. Аннотации JAX-WS](#2-аннотации-jax-ws)
    - [3. Конфигурация, регистрирующая в Consul пул сервисов libreoffice … обработкой документов. Сервисы расположены на машинах aqua, …, по пути /usr/bin/soffice. Конфигурация должна обеспечивать проверку запущены ли экземпляры сервисов.](#3-конфигурация-регистрирующая-в-consul-пул-сервисов-libreoffice--обработкой-документов-сервисы-расположены-на-машинах-aqua--по-пути-usrbinsoffice-конфигурация-должна-обеспечивать-проверку-запущены-ли-экземпляры-сервисов)
  - [Вариант 14](#вариант-14)
    - [1. UDDI](#1-uddi)
    - [2. Design for failure](#2-design-for-failure)
    - [3. конфиг для консула чтобы зарегать 3 бд](#3-конфиг-для-консула-чтобы-зарегать-3-бд)
  - [Вариант 15](#вариант-15)
    - [1. Service Discovery в решениях на базе Spring Cloud Netflix](#1-service-discovery-в-решениях-на-базе-spring-cloud-netflix)
    - [2. Сервисные шины особенности, преимущества и недостатки, использование в решениях на базе SOA](#2-сервисные-шины-особенности-преимущества-и-недостатки-использование-в-решениях-на-базе-soa)
    - [3. Набор микросервисов на Spring MVC, реализующий параллельную сортировку элементов массива. Алгоритм сортировки мож но выбрать любой подходящий.](#3-набор-микросервисов-на-spring-mvc-реализующий-параллельную-сортировку-элементов-массива-алгоритм-сортировки-мож-но-выбрать-любой-подходящий)


### Вариант 1

#### 1. Варианты реализации Service Discovery <br> 服务发现实现方式

Service Discovery (Обнаружение сервисов) — автоматическое обнаружение, отслеживание и контроль состояния устройств и сервисов в компьютерной сети.  
服务发现是自动发现、监视和控制计算机网络中设备和服务的状态。

Он создан для того, чтобы с минимальными затратами можно было подключить новое приложение/сервис в уже существующее окружение.  
它旨在使新的应用程序/服务能够以最低的成本连接到现有环境。


Основные функции Service Discovery  
服务发现的主要功能

- Регистрация сервисов 服务注册  
  Каждый новый экземпляр службы регистрирует свою собственную информацию в реестре при запуске.  
  每个新服务实例在启动时都会向 注册中心（Registry）登记自己的信息。
- Обнаружение сервисов 服务发现  
  Другие службы могут запрашивать реестр для поиска доступных экземпляров.  
  其他服务可以查询注册中心，找到可用的实例。
- Здоровье сервисов 健康检查    
  Отслеживает доступность услуг и автоматически обновляет данные в случае сбоя услуги.  
  监控服务的可用性，并在服务故障时自动更新。
- Балансировка нагрузки 负载均衡  
  Динамический выбор оптимального экземпляра сервиса на основе трафика.  
  根据流量动态选择最优的服务实例。

Решаемые задачи 需要解决的问题
- Реконфигурация системы  
  系统重新配置
- Упрощение администрирования  
  简化行政管理
- Горизонтальная масштабируемость  
  水平可扩展性

Варианты реализации:  
实施方案：

- Инфраструктурное ПО  
  基础设施软件
  - SD конфигурируется на уровне управления ВМ/контейнеров (e.g. docker, kubernetes)  
    SD 在 VM/容器管理层面进行配置（例如 docker、kubernetes）
- Прозрачно силами платформы (например напрямую в Java EE)  
  对平台透明（例如，直接在 Java EE 中）
- Используя фреймворки (e.g. Spring Cloud)  
  使用框架（例如 Spring Cloud）
- Специальное прикладное ПО (Consul, Zookeeper)  
  特殊应用软件（Consul、Zookeeper）

Это load balancer! (Или 2 способа использования SD load balancer-ом)  
这是一个负载均衡器！ （或者使用 SD 负载均衡器的两种方法）

Существует два типа SD:  
SD 有两种类型：

- client-side discovery - В модели клиентского обнаружения сервисов потребитель услуги (client) напрямую запрашивает реестр сервисов, чтобы получить адрес целевого экземпляра сервиса, и вызывает этот экземпляр напрямую.
  客户端发现 - 在客户端服务发现模型中，服务消费者（client） 直接查询服务注册中心以获取目标服务实例的地址，并且直接调用该实例。  

  Процесс:
  - Поставщик услуги (Provider) после запуска регистрирует свой адрес в реестре сервисов (Service Registry). 
    服务提供者（Provider）启动后，向服务注册中心（Service Registry）注册自己的地址。
  - Клиент (Consumer) перед вызовом сервиса сначала запрашивает список доступных экземпляров в реестре сервисов. 
    客户端（Consumer）在调用服务时，首先向服务注册中心查询可用的服务实例列表。
  - Клиент выбирает один экземпляр на основе определенной стратегии балансировки нагрузки (например, циклическое распределение, случайный выбор, взвешенный алгоритм) и вызывает его напрямую. 
    客户端根据某种负载均衡策略（如轮询、随机、权重等）选择一个实例，并直接调用。

- server-side discovery - В модели серверного обнаружения сервисов клиент не запрашивает реестр сервисов напрямую, а отправляет запрос балансировщику нагрузки (Load Balancer), который запрашивает реестр и перенаправляет запрос на целевой экземпляр. 
  在服务器端服务发现模式中，客户端不会直接查询服务注册中心，而是将请求发送到一个 负载均衡器（Load Balancer），由负载均衡器来查询注册中心并转发请求到目标实例。  

  Процесс:
  - Поставщик услуги (Provider) после запуска регистрирует свой адрес в реестре сервисов.  
    服务提供者（Provider）启动后，向服务注册中心注册自己的地址。 
  - Клиент (Consumer) отправляет запрос напрямую балансировщику нагрузки, не заботясь о конкретном адресе экземпляра сервиса.  
    客户端（Consumer）直接将请求发送给负载均衡器，而不需要关心服务实例的具体地址。 
  - Балансировщик нагрузки получает список доступных экземпляров из реестра сервисов и перенаправляет запрос на подходящий экземпляр.  
    负载均衡器从注册中心获取可用的服务实例，并将请求转发给合适的实例。 

Примеры реализации:
- ZooKeeper
  - написан на Java,
  - крепок и стабилен, но тяжеловат в настройке.  
    坚固而稳定，但难以设置。  
  - устарел, почти не используется (в т.ч. требует понижение версии спринга, чтобы все заработало)  
    已过时，几乎未使用（包括需要降级 spring 版本才能使所有内容正常运行） 
- Consul
  - Server-side
  - чуть более тяжелый и медленный, чем ZooKeeper  
    比 ZooKeeper 稍重且慢 
  - Распределенный Service Discovery (ПО ставится на каждый комп)  
    分布式服务发现（软件安装在每台计算机上） 
  - работает по принципу ключ-значение  
    按照键值原则运作 
  - предлагает веб-интерфейс для работы со списками сервисов  
    提供一个用于处理服务列表的 Web 界面 
- Eureka Server
  - Clients-side
  - Обязанность — давать имена каждому микросервису.  
    职责是给每个微服务命名。 
  - Каждый сервис регистрируется в Eureka и отправляет эхо-запрос серверу Eureka, чтобы сообщить, что он активен.  
    每个服务向 Eureka 注册，并向 Eureka 服务器发送 ping 以表明它处于活动状态。  
  - Для этого сервис должен быть помечен как  `@EnableEurekaClient` (или общее - `@EnableDiscoveryClient`), а сервер `@EnableEurekaServer`.  
    为此，服务必须标记为 `@EnableEurekaClient`（或通用的 - `@EnableDiscoveryClient`），服务器必须标记为 `@EnableEurekaServer`。 


#### 2. Структура реестра UDDI <br> UDDI 注册中心结构

UDDI (Universal Description, Discovery, and Integration) — это распределенный XML-реестр, используемый для хранения и поиска метаданных веб-сервисов. Он широко применяется в SOA (Service-Oriented Architecture) для публикации и интеграции сервисов.  
UDDI (Universal Description, Discovery, and Integration) 是一种分布式的、基于 XML 的注册中心标准，用于存储和查询 Web 服务的元数据。它主要用于SOA（面向服务架构），允许企业发布、查找和集成 Web 服务。

UDDI: Universal Description, Discovery and Integration — централизованное хранилище дескрипторов WSDL со стандартизированным API. Структура состоит из:  
UDDI (Universal Description, Discovery, and Integration) 是具有标准化 API 的 WSDL 描述符的集中存储库。其结构包括：

- Белые страницы - адрес, контакты и известные идентификаторы;  
  白页——地址、联系方式和已知标识符；
  - Основная информация о компании и ее бизнесе,  
    公司及其业务的基本信息，   
  - Основная контактная информация, включая название компании, адрес, контактный телефон,  
    基本联系信息，包括公司名称、地址、联系电话、   
  - Уникальные идентификаторы для налоговых идентификаторов компании  
    公司税务识别符的唯一标识符  
- Желтые страницы - категоризация;  
  黄页 - 分类；
  - Содержат информацию о классификации бизнеса, основанную на стандартах (NAICS, UNSPSC).  
    存储业务分类信息，基于标准分类系统（如 NAICS、UNSPSC）。  
  - более подробная информация о компании (описания электронных возможностей, которые компания может предложить любому, кто хочет иметь с ней дело)  
    有关公司的更多详细信息（描述公司可以向任何想要与其做生意的人提供的电子机会）   
  - Желтые страницы используют общепринятые схемы промышленной классификации, отраслевые коды, коды идентификации предприятий  
    黄页使用行业分类方案、行业代码和企业识别码  
  - Позволяют искать сервисы по отраслям, географии и типу бизнеса. 
    允许按行业、地理位置、业务类型查找服务。  
- Зеленые страницы - техническая информация о сервисе.  
  绿页——有关该服务的技术信息。  
  - Различные интерфейсы  
    多种接口  
  - API
  - Информация об обнаружении и аналогичные данные, необходимые для поиска, связи и запуска веб-службы  
    发现定位、通信和启动网络服务所需的信息和类似数据  

Белые страницы <br> 白页 | Жёлтые страницы <br> 黄页 | Зелёные страницы <br> 绿页
---------------|-----------------|-----------------
Наименование компании. <br> 公司名称 | Список предоставляемых сервисов. <br> 所提供服务列表 | Техническая информация о сервисах. <br> 有关服务的技术信息
Контактная информация. <br> 联系信息 | Индустриальные коды (а-ля ОКВЭД). <br> 工业代码（根据 ОКВЭД） | Спецификация API. <br> API 规范
Краткое описание. <br>  | Почтовые и географические индексы. <br> 简要描述 | Связывающие шаблоны. <br> 链接模板
Идентификаторы (ИНН / КПП и тд и тп). <br> 标识符（ИНН / КПП 等）

Помимо этого, имеют место четыре типа записей:  
此外，还有四种类型的记录：

- Business Entity — описывает бизнес, предоставивший данный сервис, эта запись включает информацию о категории, помогающую поисковым системам выполнять поиск для определенного типа бизнеса.  
  商业实体 - 描述提供服务的企业，此记录包含类别信息，以帮助搜索引擎搜索特定类型的企业。
- Business Service — класс сервисов внутри бизнеса. Каждый бизнес-сервис принадлежит нескольким бизнес-записям Business Entity.  
  商业服务 — 商业内的一类服务。每个业务服务属于多个业务实体业务记录。
- Binding Template (шаблон связывания) и Technology Model (технологическая модель) совместно определяют веб-сервис, как это описано в WSDL. Технологическая модель соответствует абстрактному описанию, а шаблон связывания соответствует протоколу.  
  绑定模板和技术模型一起定义 WSDL 中描述的 Web 服务。技术模型对应抽象描述，绑定模式对应协议。

#### 3. Сервис на JAX-WS реализующий DNS <br> 实现 DNS 的 JAX-WS 服务

```java
package dnsservice.endpoint;

import javax.jws.WebService;
import javax.jws.WebMethod;
import javax.jws.WebParam;

@WebService(name = "DNS")
public class DNS {

    private Map<String, String> dnsRecords = new HashMap<>();

    public void DNS () {};

    @WebMethod
    public String getIPAddress(@WebParam(name = "domain") String domain) {
        return dnsRecords.get(domain);
    }

    @WebMethod
    public String updateIPAddress(@WebParam(name = "domain") String domain,
                                  @WebParam(name = "ip") String ip) {
        dnsRecord.put(domain, ip);
        return dnsRecords.get(domain);
    }
    
    @WebMethod
    public String deleteIPAddress(@WebParam(name = "domain") String domain) {
        //…if contains, .remove(domain)…, else, …
    }
    
    @WebMethod
    public String addIPAddress(@WebParam(name = "domain") String domain,
                               @WebParam(name = "ip") String ip) {
        //…
    }
}
```

Публикуем сервис:

```java
public class DNSServicePublisher {
    public static void main(String[] args) {
        Endpoint.publish(
                "http://localhost:8080/dns",
                new DNS()
        );
    }
}
```

### Вариант 2

#### 1. Service Discovery на Java EE и его реализации <br> Java EE 中的服务发现及其实现

JNDI (Java Naming and Directory Interface) — это механизм Service Discovery в Java EE (Jakarta EE), который позволяет находить и получать доступ к распределенным ресурсам, таким как базы данных, EJB-компоненты, очереди сообщений (JMS), удаленные объекты (RMI) и другие.  
JNDI（Java Naming and Directory Interface） 是 Java EE（Jakarta EE） 提供的 服务发现机制，用于查找和访问分布式环境中的资源，如 数据库、EJB 组件、消息队列（JMS）、远程对象（RMI） 等。

Все сервисы “by design” регистрируются в JNDI и доступны через CDI  
所有“按设计”的服务均在 JNDI 中注册并可通过 CDI 访问

Поиск DataSource через JNDI  
通过 JNDI 查找 DataSource

1. Конфигурация DataSource на сервере (например, WildFly)  
   在服务器（如 WildFly）中配置 DataSource

   ```xml
   <subsystem xmlns="urn:jboss:domain:datasources:5.0">
       <datasources>
           <datasource jndi-name="java:/jdbc/MyDS" pool-name="MyDS">
               <connection-url>jdbc:mysql://localhost:3306/mydb</connection-url>
               <driver>postgresql</driver>
               <security>
                   <user-name>postgres</user-name>
                   <password>password</password>
               </security>
           </datasource>
       </datasources>
   </subsystem>
   ```
2. Использование JNDI для поиска DataSource в Java  
   在 Java 代码中使用 JNDI 查找 DataSource

   ```java
   public class JNDIDataSourceExample {
       public static void main(String[] args) {
           try {
               Context ctx = new InitialContext();
               DataSource ds = (DataSource) ctx.lookup("java:/jdbc/MyDS"); // 查找 JNDI 绑定的数据源
               Connection conn = ds.getConnection();
               System.out.println("成功连接数据库！");
               conn.close();
           } catch (Exception e) {
               e.printStackTrace();
           }
       }
   }
   ```

Поиск компонентов EJB через JNDI  
通过 JNDI 查找 EJB 组件

1. Регистрация EJB на сервере  
   在 EJB 服务器端注册 EJB

   ```java
   @Stateless
   public class HelloServiceBean implements HelloService {
       public String sayHello(String name) {
           return "Hello, " + name;
       }
   }
   ```

2. Поиск и вызов EJB через JNDI на клиенте
   在客户端通过 JNDI 查找并调用 EJB

   ```java
   public class EJBClient {
       public static void main(String[] args) {
           try {
               Context ctx = new InitialContext();
               HelloService helloService = (HelloService) ctx.lookup("java:global/MyApp/HelloServiceBean");
               System.out.println(helloService.sayHello("Tolia"));
           } catch (NamingException e) {
               e.printStackTrace();
           }
       }
   }
   ```

Поиск очереди JMS через JNDI  
通过 JNDI 查找 JMS 队列

1. Определение JMS-ресурса на сервере  
   在服务器端定义 JMS 资源

   ```xml
   <jms-destinations>
       <jms-queue name="MyQueue">
           <entry name="java:/jms/queue/MyQueue"/>
       </jms-queue>
   </jms-destinations>
   ```
2. Поиск JMS-очереди через JNDI в Java  
   在 Java 代码中通过 JNDI 查找 JMS 队列

   ```java
   public class JNDIJMSExample {
       public static void main(String[] args) {
           try {
               Context ctx = new InitialContext();
               Queue queue = (Queue) ctx.lookup("java:/jms/queue/MyQueue");
               System.out.println("成功找到 JMS 队列：" + queue.getQueueName());
           } catch (Exception e) {
               e.printStackTrace();
           }
       }
   }
   ```


- JNDI (Java Naming and Directory Interface) - Java API, которое предоставляет единообразный механизм взаимодействия Java-программы с различными службами имен и каталогов.  
  JNDI（Java 命名和目录接口）- 为 Java 程序和各种命名和目录服务之间的交互提供统一机制的 Java API。  
  “Под капотом” интеграция между JNDI и любой конкретной службой осуществляется с помощью интерфейса поставщика услуг.   
  在底层，JNDI 与任何给定服务之间的集成是通过服务提供者接口完成的。  
  JNDI нужен для того, чтобы мы могли из Java-кода получить Java-объект из некоторого "Registry" объектов (как раз JNDI) по имени объекта, привязанного к этому объекту.  
  需要 JNDI，以便我们可以通过绑定到该对象的对象名称从 Java 代码中的某个对象“注册表”（仅 JNDI）中获取该 Java 对象。  
  То есть в JNDI зарегистрированы все микросервисы, и зная “логическое имя”, можно достать физический URI, и дополнительную метаинформацию  
  也就是说，所有微服务都在 JNDI 中注册，知道“逻辑名称”，就可以获取物理 URI 和附加元信息
- CDI — это Contexts and Dependency Injection. Это спецификация Java EE, описывающая внедрение зависимостей (Dependency Injection) и контексты.  
  CDI 是上下文和依赖注入。这是描述依赖注入和上下文的 Java EE 规范。

Конфигурация сервера приложений может быть распределённой:  
应用服务器配置可以分布式：
- В виде пула экземпляров сервера.  
  以服务器实例池的形式。
- В виде кластера.  
  以集群的形式。

Если логику “под капотом” реализуют EJB, их можно масштабировать.  
如果“底层”逻辑由 EJB 实现，那么它们就可以扩展。

<По идее надо бы раскрыть, но хз че можно вписать>

Различные реализации Java EE предоставляют дополнительные механизмы для реализации Service Discovery. Например, Apache Tomcat имеет свой механизм обнаружения служб, а JBoss предлагает JMX для обнаружения служб. Также есть несколько реализаций Service Discovery на основе JAX-WS.  
各种 Java EE 实现提供了用于实现服务发现的附加机制。例如，Apache Tomcat 有自己的服务发现机制，JBoss 提供 JMX 用于服务发现。还有几个基于 JAX-WS 的服务发现实现。

#### 2. Понятие микросервиса. Отличия и сходства от других сервисов. <br> 微服务的概念。与其他服务的区别和相似之处。

Микросервисы – это шаблон сервис-ориентированной архитектуры, в котором приложения создаются как совокупность различных наименьших независимых (или слабо связанных), легко изменяемых модулей - микросервисов.  
微服务是一种面向服务的架构模式，其中应用程序构建为不同、较小、独立（或松散耦合）、易于更改的模块集合，称为微服务。

Нет четкой спецификации и стандартна, это больше “идеология”.  
没有明确的规范和标准，它更像是一种“意识形态”。

Микросервис - разновидность SOA, но есть различия:  
微服务是 SOA 的一种，但有区别：
- SOA ориентирована на повторное использование сервисов приложений, а микросервисы – на разъединение.  
  SOA注重应用服务的重用，而微服务注重解耦。
- SOA является полнофункциональным по своей природе, а Microservices – монолитным (поэтому MSA не предоставляет явной поддержки для разработки распределенных приложений)  
  SOA 本质上是全栈的，而微服务是单片的（因此 MSA 不提供对开发分布式应用程序的明确支持）
- SOA-приложения созданы для выполнения многочисленных бизнес-задач, а в MSA выполняет одну бизнес-задачу. Поэтому SOA лучше для крупномасштабных интеграций, а MSA для небольших веб-приложений.  
  SOA应用程序旨在执行多项业务任务，而MSA则执行一项业务任务。因此，SOA 更适合大规模集成，而 MSA 更适合小型 Web 应用程序。
- SOA предполагает совместное хранение данных между службами, тогда как в микросервисах каждая служба может иметь независимое хранилище данных.  
  SOA 假设服务之间共享数据存储，而在微服务中，每个服务可以拥有独立的数据存储。
- SOA предназначен для совместного использования ресурсов между службами, а микросервисы – для размещения служб, которые могут функционировать независимо (или хотя бы ограниченный контекст для связи).  
  SOA 用于在服务之间共享资源，而微服务用于托管可以独立运行的服务（或至少具有有限的通信环境）。
- В архитектуре SOA DevOps и Непрерывная доставка становятся популярными, но еще не стали массовыми, в то время как микросервисы уделяют большое внимание DevOps и Непрерывной доставке.  
  在SOA架构中，DevOps和持续交付正在逐渐流行但尚未成为主流，而微服务则重点关注DevOps和持续交付。
- SOA – это менее масштабируемая архитектура, а Microservices – очень масштабируемая архитектура.  
  SOA 是一种可扩展性较差的架构，而微服务是一种可扩展性很好的架构。

Критерий <br> |	Монолит <br> 单体架构 |	SOA <br> |	Микросервисы <br> 微服务
---------|---------|-----|-------------
Разделение <br> 模块划分 |	Всё в одном приложении <br> 所有功能集中在一个应用中	| Сервисы с общей шиной (ESB) 通过企业服务总线（ESB）连接的多个服务 <br>	| Независимые сервисы <br> 独立的微服务
Связность<br> 耦合度		| Жёсткая зависимость <br> 高度耦合	| Средняя (ESB) <br> 中等耦合（ESB）	| Слабая (REST, gRPC) <br> 低耦合（REST, gRPC）
Масштабируемость <br> 可扩展性	| Трудно масштабировать частично <br> 难以进行局部扩展		| Частично масштабируемо <br> 可以部分扩展	| Горизонтально масштабируемо <br> 水平扩展
Развертывание <br> 部署方式	| Обновление всего приложения <br> 需要整体更新应用		| Отдельные сервисы, но зависят от ESB <br> 单独部署服务，但依赖 ESB	| Полностью независимо <br> 完全独立部署
Технологическая зависимость <br> 技术栈	| Единый стек технологий <br> 统一的技术栈	| Общий стек внутри SOA <br> 共享 SOA 内部的技术栈		| Разные технологии для разных сервисов <br> 每个微服务可以使用不同的技术
Фрагментация данных <br> 数据存储	| Одна общая БД <br> 使用一个统一的数据库	| Централизованная БД или шина данных <br> 采用集中式数据库或数据总线		| У каждого сервиса своя БД <br> 每个服务拥有独立的数据库

Сходства микросервисов с другими сервисами  
微服务与其他架构的相似之处

- Как SOA (Service-Oriented Architecture)  
  SOA（面向服务架构）
  - Оба разделяют систему на отдельные сервисы.  
    都将系统划分为独立的服务。 
  - Оба используют API для связи между сервисами.  
    两者都使用 API 在服务之间进行通信。 
  - Оба могут использовать разные технологии.  
    两者可以使用不同的技术。 
- Как веб-сервисы (REST, SOAP)  
  作为 Web 服务（REST、SOAP）
  - Микросервисы часто используют REST API или gRPC для взаимодействия.  
    微服务通常使用 REST API 或 gRPC 进行通信。 
  - Каждый сервис предоставляет определённую функциональность, как и веб-сервис.  
    每项服务都提供特定的功能，就像 Web 服务一样。 

- Как контейнеризированные сервисы (Docker, Kubernetes)  
  作为容器化服务（Docker、Kubernetes）
  - Микросервисы обычно работают в контейнерах и масштабируются динамически.  
    微服务通常在容器中运行并动态扩展。 
  - Используют оркестраторы (Kubernetes, Docker Swarm) для управления.  
    使用编排器（Kubernetes、Docker Swarm）进行管理。 
  
Основные характеристики микросервисов  
微服务的主要特点

- Разделение на независимые сервисы  
  独立的服务拆分
  Каждый сервис решает одну бизнес-задачу.  
  每项服务解决一个业务问题。  
  - Аутентификация 验证
  - Заказы 订单
  - Оплата 支付

- Своя база данных у каждого сервиса  
  每个服务有自己的数据库  
  Микросервисы не используют общую базу данных (в отличие от монолита).  
  微服务不共享公共数据库（与整体式架构不同）。

- Независимое развертывание  
  独立部署  
  Можно обновлять один сервис без остановки всего приложения.  
  您可以更新一项服务而无需停止整个应用程序。

- Горизонтальное масштабирование  
  水平扩展  
  Можно увеличить количество экземпляров конкретного сервиса.  
  可以增加特定服务的实例数量。

- Использование API  
  API 通信  
  Связь между сервисами идёт через REST, gRPC, AMQP (Kafka, RabbitMQ).  
  服务之间的通信通过 REST、gRPC、AMQP（Kafka、RabbitMQ）进行。

- Автоматизация CI/CD  
  自动化 CI/CD  
  Каждый микросервис разрабатывается и разворачивается независимо с помощью Jenkins, GitHub Actions, ArgoCD.  
  每个微服务都使用 Jenkins、GitHub Actions、ArgoCD 独立开发和部署。

#### 3. Написать двухтарифный счётчик электроэнергии для интеграции его в ИС-предприятия на JAX-WS <br> 编写双费率电表，以便将其集成到 JAX-WS 上的企业信息系统中

```java
import javax.jws.WebService;
import javax.jws.WebMethod;
import javax.jws.WebParam;

@WebService(name = "ElectricityMeterService")
public class ElectricityMeterService {
    
    @WebMethod
    public double getCurrentPowerConsumption(@WebParam(name = "tariff") int tariff) {
        // Реализация метода
    }
    
    @WebMethod
    public double getTotalPowerConsumption(@WebParam(name = "tariff") int tariff) {
        // Реализация метода
    }
    
    @WebMethod
    public String setTariff(@WebParam(name = "tariff") int tariff) {
        // Реализация метода
    }
    
    @WebMethod
    public String getCurrentTariff(@WebParam(name = "tariff") int tariff) {
        // Реализация метода
    }
    
    @WebMethod
    public GetInformationAboutTariffsRes getInformationAboutTariffs() {
        // Реализация метода
    }
}
```

### Вариант 3

#### 1. Концепция Service Discovery. <br> 服务发现的概念。

Service Discovery (Обнаружение сервисов) — автоматическое обнаружение, отслеживание и контроль состояния устройств и сервисов в компьютерной сети.  
服务发现是自动发现、监视和控制计算机网络中设备和服务的状态。

Он создан для того, чтобы с минимальными затратами можно было подключить новое приложение/сервис в уже существующее окружение.  
它旨在使新的应用程序/服务能够以最低的成本连接到现有环境。

Основные функции Service Discovery  
服务发现的主要功能

- Регистрация сервисов 服务注册  
  Каждый новый экземпляр службы регистрирует свою собственную информацию в реестре при запуске.  
  每个新服务实例在启动时都会向 注册中心（Registry）登记自己的信息。
- Обнаружение сервисов 服务发现  
  Другие службы могут запрашивать реестр для поиска доступных экземпляров.  
  其他服务可以查询注册中心，找到可用的实例。
- Здоровье сервисов 健康检查    
  Отслеживает доступность услуг и автоматически обновляет данные в случае сбоя услуги.  
  监控服务的可用性，并在服务故障时自动更新。
- Балансировка нагрузки 负载均衡  
  Динамический выбор оптимального экземпляра сервиса на основе трафика.  
  根据流量动态选择最优的服务实例。

Решаемые задачи  
需要解决的问题
- Реконфигурация системы.  
  系统重新配置。
- Упрощение администрирования.  
  简化行政管理。
- Горизонтальная масштабируемость.  
  水平可扩展性。
- Общая концепция универсальна (искать можно не только веб-сервисы!)  
  一般概念是通用的（您不仅可以搜索网络服务！）
- Варианты реализации (не являются прямыми альтернативами!):  
  实施方案（不是直接替代方案！）：
  - Инфраструктурное ПО (Kubernetes, nginx...).  
    基础设施软件（Kubernetes、nginx……）。  
  - Специальное прикладное ПО (Consul, ZooKeeper, Etcd...).  
    特殊应用软件（Consul，ZooKeeper，Etcd...）。  
  - “Прозрачно” силами платформы (Java EE).  
    通过平台 (Java EE) “透明” 地实现。  
  - Фреймворк (Spring Cloud [Netflix]).  
    框架（Spring Cloud [Netflix]）。  

Два типа SD и варианты реализации см. [Вариант 1. Вопрос 1](#1-варианты-реализации-service-discovery)  
两种类型的 SD 和实施选项参见 [Вариант 1. Вопрос 1](#1-варианты-реализации-service-discovery)  

#### 2. Smart endpoints & Dumb pipes в МСА. <br> 微服务架构中的“智能端点&愚蠢管道”

Smart Endpoints & Dumb Pipes（智能端点 & 愚蠢管道）是微服务架构（MSA，Microservices Architecture）的核心原则之一。它强调业务逻辑应该集中在微服务中（智能端点），而通信管道应尽可能简单（愚蠢管道）。

Smart Endpoints – 智能端点

Умные конечные точки — это сами микросервисы, которые должны:  
智能端点指的是微服务自身，它们应该：

- Самостоятельно обрабатывать данные 自主处理数据 
  每个微服务都有独立的业务逻辑。
- Общаться напрямую друг с другом 直接通信
  使用 API（如 REST, gRPC）进行交互。
- Минимально зависеть от централизованных решений 尽量减少对中央组件的依赖。

Dumb Pipes – 愚蠢管道

Глупые трубы относятся к максимально возможному упрощению каналов связи между службами. Его характеристики:  
愚蠢管道指的是尽量简化服务之间的通信通道，其特点：

- Передача сообщений без сложной логики  
  不包含复杂的逻辑，仅负责传输数据。
- Легковесные протоколы: HTTP (REST), AMQP, Kafka, gRPC. 
  轻量级协议：HTTP (REST), AMQP, Kafka, gRPC。
- Отсутствие централизованного контроля, Предотвращение единой точки отказа (SPOF)  
  避免中央控制点，防止单点故障（SPOF）。

Традиционный SOA (умные каналы, немые конечные точки)  
传统 SOA（智能管道，愚蠢端点）

В архитектуре SOA ESB обрабатывает такие функции, как маршрутизация данных, преобразование, бизнес-логика и аутентификация личности, что делает ESB сложным и трудным для расширения.  
在 SOA 架构 中，ESB 处理 数据路由、转换、业务逻辑、身份认证 等功能，导致 ESB 变得复杂且难以扩展。

Пример 示例：

1. Служба заказов отправляет запрос в ESB.  
   订单服务发送请求到 ESB。
2. ESB анализирует запрос и вызывает службу инвентаризации для проверки инвентаря.  
   ESB 解析请求，调用 库存服务 检查库存。
3. ESB вызывает платежный сервис для обработки логики платежа.  
   ESB 调用 支付服务 处理支付逻辑。
4. После того, как ESB обработает всю бизнес-логику, он возвращает результат заказа.  
   ESB 处理完所有业务逻辑后，返回订单结果。

проблемы 问题：

- ESB перегружена и становится узким местом.  
  ESB 过载，成为瓶颈。
- Единая точка отказа (SPOF): если ESB выходит из строя, вся система перестает функционировать.  
  单点故障（SPOF），如果 ESB 崩溃，整个系统无法运行。
- Услуги тесно связаны, и изменение одного процесса может повлиять на несколько услуг.  
  服务之间高度耦合，修改一个流程可能影响多个服务。

Архитектура микросервисов (умные конечные точки, глупые каналы)  
微服务架构（智能端点，愚蠢管道）

В архитектуре микросервисов каждый микросервис обрабатывает собственную бизнес-логику, а коммуникационные конвейеры (такие как REST, gRPC, Kafka) используются только для передачи данных.
在 微服务架构 中，每个微服务自己处理业务逻辑，通信管道（如 REST、gRPC、Kafka）仅用于数据传输。

Пример 示例：

1. Служба заказов напрямую обращается в Службу инвентаризации для проверки наличия товара на складе.  
   订单服务 直接调用 库存服务 检查库存。
2. Служба заказа напрямую обращается к платежной службе для осуществления платежа.  
   订单服务 直接调用 支付服务 进行支付。
3. Платежный сервис асинхронно уведомляет через Kafka об оплате заказа.  
   支付服务 通过 Kafka 异步通知 订单已支付。
4. Заказать услугу Обновить статус заказа.  
   订单服务 更新订单状态。

преимущество 优点：

- Каждый микросервис автономен и не нуждается в центральной ESB.  
  各个微服务自主，无须依赖中央 ESB。
- Уменьшить сложность коммуникационного уровня и избежать дополнительных накладных расходов.  
  降低通信层复杂度，避免额外开销。
- Более высокая эластичность и масштабируемость, каждый микросервис можно независимо расширять или заменять.  
  更高的弹性和可扩展性，各个微服务可以独立扩展或替换。

#### 3. Сервис Jax-ws по менеджменту учащихся. <br> Jax-ws 学生管理服务。

```java
@WebService(endpointInterface = "shit.soa.StudentManagmentService")
public class StudentManagmentServiceImpl implements StudentManagmentService {
    
    @Inject
    private StudentManagmentRepository rep;
    
    @WebMehtod(operationName = "getAllStudents")
    @WebResult(name="student_list_dto")
    public StudentsListDTO getAllStudents(@WebParam(name="get_students_req_dto")
                                          GetAllStudentsReqDTO req) {
        return new StudentsListDTO().getStudents().addAll(rep.getStudents());
    }
    
    @WebMehtod(operationName = "getStudent")
    @WebResult(name="student")
    public Student getStudent(@WebParam(name="get_student_req_dto") GetStudentReqDTO req) {
        return rep.getStudent(req.getId)
    }
    
    @WebMehtod(operationName = "addStudent")
    @WebResult(name="student")
    public Student addStudent(@WebParam(name="add_student_req_dto") AddStudentReqDTO req) {
        return rep.addStudent(req.getName, req.getGroup, ...);
    }
    
    @WebMehtod(operationName = "updateStudent")
    @WebResult(name="student")
    public Student updateStudent(@WebParam(name="update_student_req_dto") UpdateStudentReqDTO req) {
        return rep.updateStudent(req.getId, req.getName, req.getGroup, ...);
    }
    
    //...
}
```

### Вариант 4

#### 1. Service Discovery в решениях на базе Spring Cloud Netflix <br> Spring Cloud Netflix 解决方案中的服务发现

Spring Cloud Netflix - Бандл для построения SOA-систем на базе Spring Cloud и стека Netflix OSS:  
Spring Cloud Netflix - 基于 Spring Cloud 和 Netflix OSS 堆栈构建 SOA 系统的软件包：
- Eureka Server для SD.
- Балансировщик нагрузки Ribbon.  
  Ribbon 负载均衡器。
- Hystrix Circuit Breaker

В экосистеме Spring Cloud Netflix обнаружение сервисов является основной частью архитектуры микросервисов. Он позволяет экземплярам служб динамически регистрироваться и находить друг друга во время выполнения без жесткого кодирования адресов служб.  
在 Spring Cloud Netflix 生态系统中，服务发现（Service Discovery） 是微服务架构的核心部分。它允许服务实例在运行时 动态注册 和 查找 彼此，而无需硬编码服务的地址。

Spring Cloud Netflix предоставляет client-side SD - Eureka.  
Spring Cloud Netflix 提供客户端 SD - Eureka。

Основные компоненты Service Discovery  
服务发现的核心组件
- Eureka Server   
  Eureka Server - Выступает в качестве центра регистрации микросервисов и отвечает за ведение всех зарегистрированных экземпляров сервисов. При запуске экземпляра службы он регистрируется на сервере Eureka и периодически отправляет тактовые импульсы, чтобы указать, что он все еще доступен.  
  Eureka Server 充当微服务的 注册中心，负责维护所有注册的服务实例。服务实例启动时会向 Eureka Server 进行注册，并定期发送心跳来表明自己仍然可用。
- Eureka Client  
  Eureka Client — поставщик микросервисов. Он регистрируется на Eureka Server при запуске и регулярно отправляет сигналы heartbeat, чтобы указать, что он доступен.  
  Eureka Client 是微服务的 提供者，它会在启动时向 Eureka Server 进行注册，并定期发送心跳信号，表明自己可用。
- Eureka Consumer  
  Eureka Consumer — потребитель микросервисов. Он обнаруживает адреса других микросервисов через Eureka Server и вызывает их.  
  Eureka Consumer 是微服务的 消费者，它通过 Eureka Server 发现其他微服务的地址，并调用它们。

Напомним, что client-side discovery - клиент запрашивает информацию о доступе к доступным экземплярам у SD, а дальше сам распределяет нагрузку между ними. В Client-side SD единственной «фиксированной точкой» в архитектуре является Service Registry, в котором должна регистрироваться каждая служба. Клиент сам имплементирует логику для взаимодействия со службой.  
让我们回想一下，客户端发现是指客户端从 SD 请求有关访问可用实例的信息，然后在它们之间分配负载。在客户端 SD 中，架构中唯一的“固定点”是服务注册表，每个服务都必须在此注册。客户端实现与服务本身交互的逻辑。

Каждый микросервис регистрируется на сервере Eureka, и Eureka знает все клиентские приложения, работающие на каждом порту и IP-адресе. Eureka Server также известен как Discovery Server.  
每个微服务都会注册到Eureka服务器上，Eureka知道每个端口和IP地址上运行的所有客户端应用程序。 Eureka 服务器也称为发现服务器。

С Netflix Eureka каждый клиент действует как “сервер” при подключении к сервису: клиент извлекает список всех подключенных экземпляров в service registry и отправляет все дальнейшие запросы к службам с помощью алгоритма балансировки нагрузки.  
使用 Netflix Eureka，每个客户端在连接到服务时都充当“服务器”：客户端从服务注册表中检索所有连接实例的列表，并使用负载平衡算法将所有进一步的请求发送到服务。

Обязанность Eureka — давать имена каждому микросервису. Эврика регистрирует микросервисы и отдает их ip другим микросервисам. Таким образом, каждый сервис регистрируется в Eureka и отправляет эхо-запрос серверу Eureka, чтобы сообщить, что он активен. Для этого сервис должен быть помечен как `@EnableEurekaClient`, а сервер `@EnableEurekaServer`.  
Eureka的职责是对每一个微服务进行命名。 Eureka 注册微服务并将其 IP 提供给其他微服务。因此，每个服务都会向 Eureka 注册并 ping Eureka 服务器以让其知道它处于活动状态。为此，必须将服务标记为“@EnableEurekaClient”，将服务器标记为“@EnableEurekaServer”。

#### 2. Технология JAX-WS и её использование для реализации веб-сервисов <br> JAX-WS 技术及其在实现 Web 服务中的应用

Java API for XML Web Services (JAX-WS) — это прикладной программный интерфейс языка Java для создания веб-служб, входит в спецификацию Java EE.  
Java API for XML Web Services (JAX-WS) 是用于创建 Web 服务的 Java API，是 Java EE 规范的一部分。

JAX-WS является заменой технологии JAX-RPC, предоставляя более документо-ориентированную модель сообщений и упрощая разработку веб-служб за счёт использования аннотаций. Основан на разметке класса аннотациями (метапрограммировании), хорошо совместим с EJB.  
JAX-WS 是 JAX-RPC 技术的替代品，它提供了更加面向文档的消息传递模型，并通过使用注释简化了 Web 服务开发。基于带有注释的类标记（元编程），它与 EJB 具有良好的兼容性。

В JAX-WS вызов операции веб-сервиса представлен протоколом SOAP — протоколом на основе XML. Спецификация SOAP определяет:  
在 JAX-WS 中，Web 服务操作调用由 SOAP 协议（​​一种基于 XML 的协议）表示。 SOAP 规范定义：

- структуру сообщения, 消息结构，
- правила кодирования 编码规则
- соглашения для представления вызовов и ответов веб-сервиса.  
  表示 Web 服务调用和响应的约定。

Эти вызовы и ответы передаются как сообщения SOAP (файлы XML) по HTTP.  
这些调用和响应通过 HTTP 以 SOAP 消息（XML 文件）的形式传输。

На стороне сервера разработчик:  
在服务器端，开发人员：

- специфицирует операции веб-сервиса, определяя методы в интерфейсе, написанном на Java.  
  通过在用 Java 编写的接口中定义方法来指定 Web 服务的操作。
- Пишет классы с реализацией этих методов.  
  编写实现这些方法的类。

Для реализации клиентских классов, рахработчик:  
为了实现客户端类，开发人员需要：

- создает прокси (локальный объект, представляющий сервис),  
  创建代理（代表服务的本地对象），
- затем просто вызывает методы на прокси.  
  然后只需调用代理上的方法。

Кроме того, JAX-WS не ограничивает ни одну из сторон в используемых технологиях: клиент JAX-WS может получить доступ к веб-сервису, который не работает в платформе Java, и наоборот. Эта гибкость возможна благодаря использованию в JAX-WS технологий, определённых W3C: HTTP, SOAP и WSDL. WSDL определяет формат XML для описания сервиса как набора конечных точек, работающих с сообщениями.  
此外，JAX-WS 不限制任何一方所使用的技术：JAX-WS 客户端可以访问不在 Java 平台上运行的 Web 服务，反之亦然。这种灵活性是可能的，因为 JAX-WS 使用了 W3C 定义的技术：HTTP、SOAP 和 WSDL。 WSDL 定义了一种 XML 格式，用于将服务描述为一组消息处理端点。

Можно генерировать: WSDL <-> code (в обе стороны).  
可以生成：WSDL <-> 代码（双向）。

Аннотации JAX-WS  
JAX-WS 注释

- `@WebService` — указывает на то, что Java класс (или интерфейс) является веб-сервисом.  
  `@WebService` - 表示 Java 类（或接口）是一个 Web 服务。
- `@WebMethod` — позволяет настроить то, как будет отображаться метод класса на операцию сервиса.  
  `@WebMethod` - 允许您自定义如何将类方法映射到服务操作。
- @WebParam — позволяет настроить то, как будет отображаться конкретный параметр операции на WSDL-часть (part) и XML элемент.  
  @WebParam - 允许您自定义如何在 WSDL 部分和 XML 元素上显示特定的操作参数。
- `@WebResult` — позволяет настроить то, как будет отображаться возвращаемое значение операции на WSDL-часть (part) и XML элемент.  
  `@WebResult` - 允许您自定义操作的返回值在 WSDL 部分和 XML 元素上的显示方式。
- `@Oneway` — указывает на то, что операция является односторонней, то есть не имеет выходных параметров.  
  `@Oneway` - 表示操作是单向的，即没有输出参数。
- `@SOAPBinding` — позволяет настроить то, как будет отображаться сервис на протокол SOAP.  
  `@SOAPBinding` - 允许您配置服务如何映射到 SOAP 协议。

Пример сервиса на JAX-WS: интерфейс  
示例 JAX-WS 服务：接口

```java
@WebService
public interface EmployeeService {
    @WebMethod
    Employee getEmployee(int id);
    
    @WebMethod
    Employee updateEmployee(int id, String name);
    
    @WebMethod
    boolean deleteEmployee(int id);
    
    @WebMethod
    Employee addEmployee(int id, String name);
    //...
}
```

Пример сервиса на JAX-WS: реализация  
JAX-WS 服务示例：实现

```java
@WebService(endpointInterface = "com.example.EmployeeService")
public class EmployeeServiceImpl implements EmployeeService {
    @Inject
    private EmployeeRepository employeeRepositoryImpl;

    @WebMethod
    public Employee getEmployee(int id) {
        return employeeRepositoryImpl.getEmployee(id);
    }

    @WebMethod
    public Employee updateEmployee(int id, String name) {
        return employeeRepositoryImpl.updateEmployee(id, name);
    }
    // ...
}
```

Пример сервиса на JAX-WS: публикация  
示例 JAX-WS 服务：发布

```java
public class EmployeeServicePublisher {
    public static void main(String[] args) {
        Endpoint.publish(
                "http://localhost:8080/employeeservice",
                new EmployeeServiceImpl());
    }
}
```


#### 3. Набор микросервисов на Spring MVC, управляющий распределением по аудиториям и преподавателям студентов, ожидающих своей очереди на доп. Должна поддерживаться возможность добавления новых аудиторий и преподавателей и удаления существующих. В одной аудитории может находиться более одного преподавателя. <br> 一组基于 Spring MVC 的微服务，用于管理排队等待加课的学生在教室和老师之间的分配。应该可以添加新的教室和教师，并删除现有的教室和教师。一个教室可能有多个老师。

Пишем CRUD для аудиторий, это отдельный микросервис.  
我们为观众编写 CRUD，这是一个单独的微服务。

Controller:

```java
@RestController
public class AudienceController {
    private final AudienceService audienceService;
    @Autowired
    public AudienceController(AudienceService audienceService) {
    }
    
    @GetMapping("/audiences")
    public List<Audience> getAudiences() {
        return audienceService.getAudiences();
    }
    
    @PostMapping("/audiences")
    public Audience addAudience(@RequestBody Audience audience) {
        return audienceService.addAudience(audience);
    }
    
    @DeleteMapping("/audiences/{id}")
    public void deleteAudience(@PathVariable Long id) {
        audienceService.deleteAudience(id);
    }
}
```

Application:

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class AudienceServiceApplication {
    public static void main(String[] args)
    {
        SpringApplication.run(
                AudienceServiceApplication.class,
                args);
    }
}
```

Controller:

```java
@RestController
public class TeacherController {
    //...
}
```

Application:

```java
@SpringBootApplication
public class TeacherServiceApplication {
    // ...
}
```

АНАЛОГИЧНО пишем микросервис для студентов  
就像我们为学生编写微服务一样
//...

Последний шаг - микросервис, добавляющий студентов и преподавателей в аудитории (создает класс)  
最后一步是将学生和老师添加到教室的微服务（创建班级）

```java
@RestController(path = "/class")
public class ClassController {
    
    private final ClassService classService;
    
    @Autowired
    public ClassController(ClassService ClassService) {
    }
    
    @GetMapping("/student")
    public boolean applyStudent(
            @RequestParam(name = "student_id") Long studentId,
            @RequestParam(name = "audience_id") Long audienceId) {
        return classService.applyStudent(studentId, audienceId);
    }

    //Ну...И так же препода добавляем
}
```

### Вариант 5

#### 1. Реализация микросервисов на Spring Cloud. <br> Spring Cloud 上的微服务的实现。

Spring Cloud
- Инструментарий на базе Spring для построения распределенных систем (а не облако от Spring!)  
  基于 Spring 的用于构建分布式系统的工具包
- Следующий уровень инфраструктурной иерархии (Spring -> Spring Boot -> Spring Cloud).  
  基础设施层次结构的下一级（Spring -> Spring Boot -> Spring Cloud）。
- Ключевые возможности:  
  主要特点：
  - Распределённая конфигурация с версионированием.  
    具有版本控制的分布式配置。  
  - Регистрация и автообнаружение сервисов.  
    服务的注册和自动发现。  
  - Маршрутизация вызовов.  
    呼叫路由。  
  - Организация взаимного вызова сервисов.  
    组织相互服务呼叫。  

Архитектура Spring Cloud

![](./pic/Rubiesh2-1.png)

Микросервисы на Spring Cloud  
Spring Cloud 上的微服务
- Решение “из коробки” для реализации MSA.  
  用于 MSA 实施的开箱即用解决方案。
- Расширяет возможности Spring Boot.  
  扩展 Spring Boot 的功能。
- Включает в себя следующий набор компонентов:  
  包括以下组件：
  - Spring Cloud Config Server.  
    Spring Cloud配置服务器。  
  - Auth Server. 认证服务器。
  - API Gateway. API网关。
  - Service Discovery. 服务发现。
  - Клиентский балансировщик, Circuit Breaker и HTTP-клиент.  
    客户端负载均衡器、断路器和 HTTP 客户端。  
  - Панель мониторинга. 监控面板。

#### 2. Service Discovery и Service Registry.

Service Discovery — см [Вариант 1 вопрос 1](#1-варианты-реализации-service-discovery--服务发现实现方式)

Service Discovery – это процесс, позволяющий клиентам автоматически найти и использовать доступные службы. Примерами Service Discovery могут быть DNS, различные протоколы динамической конфигурации или протоколы обнаружения служб, такие как SLP или UPnP.  
服务发现是一个使客户端能够自动查找和使用可用服务的过程。服务发现的示例包括 DNS、各种动态配置协议或服务发现协议（如 SLP 或 UPnP）。

Решаемые задачи:  
需要解决的任务：
- реконфигурация системы  
  系统重新配置
- упрощение администрирования  
  简化行政管理
- горизонтальная масштабируемость  
  水平可扩展性

Service Registry – Ключевой компонент, SD. Это хранилище данных, используемое для хранения информации об услугах, доступных для других систем. Оно может содержать информацию о местоположении служб, метаданные и обнаруженные атрибуты, протоколы доступа и другую полезную информацию. Поэтому его необходимо обновлять и регулярно поддерживать.  
服务注册表 — 关键组件，SD。它是一个数据仓库，用于存储有关其他系统可用的服务的信息。它可能包含有关服务位置、元数据和发现的属性、访问协议和其他有用信息。因此，需要定期更新和维护。

Service Registry  
服务注册中心
- API для взаимодействия с реестром сервисов.  
  用于与服务注册表交互的API。
- Есть имплементации для популярных реестров (Eureka, Consul, ZooKeeper, Kubernetes...)  
  有流行注册中心的实现（Eureka、Consul、ZooKeeper、Kubernetes……）
- Базовый интерфейс – DiscoveryClient.  
  基本接口 – DiscoveryClient。

![](./pic/Rubiesh2-2.png)

#### 3. Веб-сервис на JAX-WS, управляющий процессом выпечки колобков. Выпечка пирожка состоит из последовательности взаимозависимых этапов, выполнение которых должен обеспечивать сервис - поскребание по сусекам, подготовка теста, лепка заготовки, термическая обработка. <br> 管理烘焙 kolobok 过程的 JAX-WS Web 服务。烘烤馅饼包括一系列相互依赖的阶段，服务必须确保这些阶段的实施 - 刮擦桶底，准备面团，塑造坯料，热处理。

```java
@WebService(endpointInterface = "shit.soa.BakeryService")
public class BakeryServiceImpl extends BakeryService {
    @Inject
    private DoBakeryService doService;

    @WebMehtod(operationName = "poskrebanie")
    @WebResult(name = "poskrebanie_res_dto")
    public PoskrebanieResDto poskrebanie(@WebParam(name = "poskrebanie_req_dto")
                                         PoskrebanieReqDto req) {
        return new doService.doPoskrebanie(req); //delaet poskrebanie
    }

    @WebMehtod(operationName = "test_preparing")
    @WebResult(name = "test_preparing_res_dto")
    public TestPreparingResDto test_preparing(@WebParam(name = "poskrebanie_req_dto")
                                              TestPreparingReqDto req) {
        return new doService.doTestPreparing(req); //delaet testa preparing
    }

    @WebMehtod(operationName = "lepka")
    @WebResult(name = "lepka_res_dto")
    public LepkagResDto lepka(@WebParam(name = "lepka_req_dto") LepkaReqDto req) {
        return new doService.doLepka(req); //delaet lepka ZagotoVki
    }

    @WebMehtod(operationName = "term_handling")
    @WebResult(name = "term_handling_res_dto")
    public TermHandlingResDto termHandling(@WebParam(name = "term_handling_req_dto")
                                           TermHandlingReqDto req) {
        return new doService.doTermHandling(req); //delaet term handling
    }
}
```

### Вариант 6

#### 1. Реализация Service Discovery на уровне инфраструктурного ПО <br> 在基础设施软件层面实现服务发现

Это один из способов реализации SD в MSA и SOA. Service Discovery на уровне инфраструктурного ПО по сравнению со специальным ПО (по типу Consula) поддерживает не только Client-side SD, но и Server-Side*.  
这是在MSA和SOA中实现SD的方法之一。基础设施软件级别的服务发现，与专用软件（如 Consula）相比，不仅支持客户端 SD，还支持服务器端*。

Реализация SD происходит на уровне инфраструктурного ПО происходит с помощью конфигурирования и управления контейнерами и виртуальными машинами.  
SD 的实现发生在基础设施软件层面，通过容器和虚拟机的配置和管理。

Контейнеризация.  
容器化。

- Docker: ПО для автоматизации развёртывания и управления приложениями в средах с поддержкой контейнеризации. В отличие от развертывания виртуалок, достаточно только запустить одно Ядро и докер движок, и все контейнеры ставятся на них.  
  Docker：用于在支持容器的环境中自动部署和管理应用程序的软件。与部署虚拟机不同，您只需启动一个 Kernel 和 Docker 引擎，所有容器都安装在其上。
- Kubernetes: ПО для автоматизации развертывания, масштабирования и управления контейнеризованными приложениями. Он умеет делать Service Discovery.  
  Kubernetes。用于自动部署、扩展和管理容器化应用程序的软件。他可以进行服务发现。
  - Под — один или несколько контейнеров, гарантированно запущенные на одном узле (VM с контейнерами приложений), с разделением ресурсов, межпроцессным взаимодействием и уникальным IP-адресом.  
    Pod - 保证在单个节点（带有应用程序容器的 VM）上运行的一个或多个容器，具有资源共享、进程间通信和唯一的 IP 地址。
  - Service в kubernetes: совокупность логически связанных наборов подов и политик доступа к ним.  
    kubernetes 中的服务：逻辑相关的 pod 集合及其访问策略。 

При такой реализации возможностей гораздо больше, чем в прозрачном Java EE и специальном ПО том же.  
通过这种实现，比透明 Java EE 和特殊软件有更多可能性。

\* Что же такое Client side и server-side?  
\* 什么是客户端和服务器端？
- client-side discovery - клиент запрашивает информацию о доступе к доступным экземплярам у SD, а дальше сам распределяет нагрузку между ними  
  客户端发现 - 客户端从 SD 请求有关访问可用实例的信息，然后在它们之间分配负载
- server-side discovery - клиент использует посредника (SD) для запроса каталога услуг и выполнения запросов к ним  
  服务器端发现 - 客户端使用代理（SD）来请求服务目录并向其发出请求

#### 2. Реализация микросервисов на Java EE <br> 在 Java EE 上实现微服务

- Все сервисы “by design” регистрируются в JNDI и доступны через CDI.  
  所有“按设计”的服务均在 JNDI 中注册并可通过 CDI 访问。
- Если логику “под капотом” реализуют EJB, их можно масштабировать.  
  如果“底层”逻辑由 EJB 实现，则它们可以扩展。
- Конфигурация сервера приложений может быть распределённой:  
  应用服务器配置可以分布式：
  - В виде пула экземпляров сервера.  
    以服务器实例池的形式。 
  - В виде кластера  
    以集群形式 

Java EE: EJB Pool @ GlassFish Cluster

![](./pic/Rubiesh2-11.png)

![](./pic/Rubiesh2-12.png)

Компонент в пуле представляет состояние пула в жизненном цикле EJB. Это означает, что у bean-компонента нет идентификатора. Преимущество наличия bean-компонентов в пуле заключается в том, что время на создание bean-компонента можно сэкономить для запроса. Контейнер имеет механизмы, которые создают объекты пула в фоновом режиме, чтобы сэкономить время создания bean-компонента на пути запроса.  
池中的组件表示 EJB 生命周期中池的状态。这意味着该 bean 没有标识符。将 bean 放在池中的好处是可以节省每个请求创建 bean 所需的时间。容器具有在后台创建池对象的机制，以节省请求路径上的 bean 创建时间。

Компоненты сеанса без сохранения состояния и компоненты управления данными используют пул EJB. Помня о том, как вы используете сеансовые компоненты без сохранения состояния и объем трафика, который обрабатывает ваш сервер, настройте размер пула, чтобы предотвратить чрезмерное создание и удаление компонентов.  
无状态会话 Bean 和实体 Bean 使用 EJB 池。记住您如何使用无状态会话 Bean 以及服务器处理的流量量，调整池大小以防止过多地创建和删除 Bean。

- Подход используется относительно редко  
  该方法很少使用
- Стандартный вариант -- EJB + JAX-RS.  
  标准选项--EJB+JAX-RS。
- “Из коробки” есть Service Discovery с помощью JNDI.  
  可以使用 JNDI 进行开箱即用的服务发现。
- Можно выбирать между масштабированием на уровне экземпляров бинов и серверов приложений.  
  您可以在 Bean 实例级别和应用程序服务器级别进行扩展之间进行选择。
- Нужно выбирать максимально “лёгкие” серверы приложений (Jetty, Payara Micro etc).  
  您需要选择最“轻”的应用服务器（Jetty、Payara Micro 等）。

#### 3. Конфигурация в Consul сервиса по выпеканию пирожков с пулом экземпляров сервиса. Сервис реализован на Jakarta EE и развернут в контейнере приложений Wildfly на серверах helios, terra и aqua <br> 在 Consul 中配置带有服务实例池的馅饼烘焙服务。该服务在 Jakarta EE 上实现，并部署在 helios、terra 和 aqua 服务器上的 Wildfly 应用程序容器中

```json
{
  "services": [{
    "name": "wildfly-bakery-1",
    "address": "helios.se.ifmo.ru",
    "port": "41050",
    "checks": [{
      "id": "bakery-1-check",
      "name": "Bakery 1 Helios check",
      "http": "http://helios.se.ifmo.ru:41050/health",
      "method": "GET",
      "interval": "13s"
    }]
  },{
    "name": "wildfly-bakery-2",
    "address": "aqua",
    "port": "41050",
    "checks": [{
      "id": "bakery-2-check",
      "name": "Bakery 1 Aqua check",
      "http": "http://aqua:41050/health",
      "method": "GET",
      "interval": "13s"
    }]
  },{
    "name": "wildfly-bakery-3",
    "address": "terra",
    "port": "41050",
    "checks": [{
      "id": "bakery-2-check",
      "name": "Bakery 1 Terra check",
      "http": "http://terra:41050/health",
      "method": "GET",
      "interval": "13s"
    }]
  }]
}

```

### Вариант 7

#### 1. Consul. Назначение, архитектура, возможности <br> Consul：目的、架构、功能

Consul - server-side Система обнаружения сервисов (Service Discovery) с распределенным хранилищем “ключ-значение”. Так как является распределенным, то (ПО ставится на каждый комп). Регистрируются путём создания файлов в формате json  
Consul - 具有分布式键值存储的服务器端服务发现系统。由于它是分布式的，（该软件安装在每台计算机上）。通过创建json格式的文件进行注册

Предлагает веб-интерфейс для работы со списками сервисов.  
提供用于处理服务列表的 Web 界面。

Архитектура Consul

![](./pic/Rubiesh2-13.png)

- Agent（代理）: 运行在每个节点上，负责服务注册、健康检查、通信
- Client：轻量级代理，向服务器发送请求，不存储数据
- Server：负责管理集群、存储数据、选举 Leader
- Gossip 协议：用于节点之间的状态同步和健康检查
- Raft 共识算法：服务器间数据同步，保证一致性
- Key-Value 存储：允许应用程序存储和获取配置信息

Преимущества Consul для микросервисов  
Consul 对微服务的好处

1. Обнаружение сервисов: эта функция покрывается Consul и полезна для интеграции новых технологий в ваши микросервисы.  
   服务发现：此功能由 Consul 涵盖，对于将新技术集成到您的微服务中很有用。
2. Повышенная прозрачность: Consul полностью прозрачен и может использоваться без каких-либо зависимостей кода.  
   提高透明度：Consul 完全透明，无需任何代码依赖即可使用。
3. Конфигурация: Consul можно использовать для настройки микросервисов. Могут быть реализованы как обнаружение сервисов, так и их настройка.  
   配置：可以使用Consul来配置微服务。它既可以实现服务发现，也可以进行服务配置。
4. Балансировка нагрузки: с помощью Consul DNS Consul прозрачно реализует балансировку нагрузки с помощью DNS-сервера.  
   负载均衡：通过Consul DNS，Consul透明地使用DNS服务器实现负载均衡。

Регистрация сервисов в консуле производится с помощью функции Consul Connect. Также регистрируются политики взаимодействия, например, мы можем указать, что сервис 1 может взаимодействовать с сервисом 2, но не может взаимодействовать с сервисом 3. Также для регистрации своего приложения доступна HTTP API или конфигурационные файлы самого консула (при наличии поддержки со стороны приложения).  
使用 Consul Connect 功能在 Consul 中注册服务。交互策略也被注册，例如，我们可以指定服务1可以与服务2交互，但不能与服务3交互。此外，HTTP API或consul本身的配置文件（如果应用程序支持）也可用于注册您的应用程序。

Принцип работы server side SD: клиент использует посредника (SD - Consul’a) для запроса каталога услуг и выполнения запросов к ним.  
服务器端 SD 的运行原理：客户端使用中介（SD - Consul）请求服务目录并对其执行请求。

![](./pic/Rubiesh2-3.png)

#### 2. Микросервисы на spring boot <br> Spring Boot 上的微服务

Микросервисы на Spring Boot  
Spring Boot 上的微服务
- Де-факто – обычные веб-сервисы (Spring Web MVC REST/ Spring Data REST).  
  事实上的 – 常规 Web 服务（Spring Web MVC REST/Spring Data REST）。
- Технология интеграции – на выбор программиста.  
  集成技术由程序员自行决定。
- Для того, чтобы управлять пулами микросервисов, нужно интегрироваться с сервером имён (например, Eureka).  
  为了管理微服务池，您需要与名称服务器（例如，Eureka）集成。
- Для того, чтобы распределять нагрузку, нужно интегрироваться с балансировщиком (например, Ribbon).  
  为了分配负载，您需要与平衡器（例如，Ribbon）集成。
- Интеграция осуществляется “вручную”.  
  集成以“手动”方式进行。

Пример архитектуры

![](./pic/Rubiesh2-4.png)

Балансировка нагрузки и использование индекса

![](./pic/Rubiesh2-5.png)

#### 3. Написать на JAX-WS сервис по управлению процессом изготовления резиновых уточек

```java
@WebService(endpointInterface = "shit.soa.DuckService")
public class DuckServiceImpl extends DuckService {

    @Inject
    private DoDuckService makingService;

    @WebMehtod(operationName = "makeNewDuck")
    public MakeNewDuckResDto makeNewDuck(MakeNewDuckReqDto req) {
        return new makingService.makeNewDuck(req.getDuckParams());
        //delat' utka po params
    }

    @WebMehtod(operationName = "remakeOldDuck")
    public TestPreparingResDto remakeOldDuck(TestPreparingReqDto req) {
        return new makingService.remakeOldDuck(req.getOldDuck(). req.getDuckParams());
        //peredelat' old utka with new params
    }
    
    @WebMehtod(operationName = "destroyBadDuck")
    public DestroyBadDuckResDto destroyBadDuck(DestroyBadDuckReqDto req) {
        return new makingService.destroyBadDuck(req.getDeffectiveDuck());
        //ubit' utka with wrong params
    }
    //... fantasize!
}
```

### Вариант 8

#### 1. Service Discovery

Описание подхода
- Обнаружение сервисов (Service Discovery) — автоматическое определение устройств и сервисов, предоставляемых этими устройствами в компьютерной сети.
- Протоколы обнаружения сервисов (Service Discovery Protocol) — сетевые протоколы, реализующие SD.
- Таких протоколов много: DNS SD , Dynamic Host Configuration Protocol (DHCP), Service Location Protocol (SLP), Universal Description Discovery and Integration (UDDI) для веб-сервисов, Web Proxy Autodiscovery Protocol (WPAD)...

SD создан для того, чтобы с минимальными затратами можно подключить новое приложение в уже существующее наше окружение. Используя Service Discovery, мы можем максимально разделить либо контейнер в виде докера, либо виртуальный сервис от того окружения, в котором он запущен.

Решаемые задачи
- Реконфигурация системы.
- Упрощение администрирования.
- Горизонтальная масштабируемость.
- Общая концепция универсальна (искать можно не только веб-сервисы!)
- Варианты реализации (не являются прямыми альтернативами!):
  - Инфраструктурное ПО (Kubernetes, nginx...).
  - Специальное прикладное ПО (Consul, ZooKeeper, Etcd...).
  - “Прозрачно” силами платформы (Java EE).
  - Фреймворк (Spring Cloud [Netflix]).
  
Два типа SD и варианты реализации см. [Вариант 1. Вопрос 1](#1-варианты-реализации-service-discovery)

#### 2. Smart Endpoints & Dump pipes

Smart endpoints & Dumb pipes (SE & DP) - паттерн MSA для взаимодействия микросервисов по сети.

Начнем с контрпримера: в ESB реализован подход «умный канал и глупые сервисы»: умный канал — шина ESB, глупые сервисы — конечные системы. В противовес ESB, существует подход «умные сервисы и глупые каналы», используемый в МСА. Суть в том, что микросервисы (смарт эндпоинтс) должны выполнять свою собственную коммуникационную логику, а надстройка (pipes) по передаче сообщений (“from endpoint to endpoint”) должна иметь как можно более легковесную структуру.

В виде каналов в данном подходе выступают различные брокеры:
- Брокеры сообщений (message broker) - выступает посредником:
преобразует сообщение по одному протоколу от приложения-источника в сообщение протокола приложения-приёмника. Так же брокер, например, проверяет сообщение на ошибки, маршрутизирует, и выполняет еще ряд функций (но тем не менее не бизнес-логику, оставаясь “dumb”)
- Событийные брокеры (event broker) - используется для передачи событий по схеме publish-subscribe.

А в виде сервисов — шлюзы (API Gateway), которые скрывают за собой реализацию и выносят наружу для взаимодействия API.

Плюсы:

- Возможность построения слабосвязанных систем
- Гибкость настройки, взаимозаменяемость инструментов взаимодействия
- Быстрота взаимодействия

Минусы:

- Сложность проектирования и реализации системы
- Требуются практики DevOps по настройке окружения
- В связи с общим трендом на микросервисы в корпоративной разработке, стоимость труда специалистов увеличивается


#### 3. Jax-ws сервис по управлению контингентом в университете

```java
@WebService(endpointInterface = "shit.soa.StudentManagmentService")
public class StudentManagmentServiceImpl extends StudentManagmentService {
    
    @Inject
    private StudentManagmentRepository rep;
    
    @WebMehtod(operationName = "getAllStudents")
    @WebResult(name="student_list_dto")
    public StudentsListDTO getAllStudents(@WebParam(name="get_students_req_dto")
                                          GetAllStudentsReqDTO req) {
        return new StudentsListDTO().getStudents().addAll(rep.getStudents());
    }
    
    @WebMehtod(operationName = "getStudent")
    @WebResult(name="student")
    public Student getStudent(@WebParam(name="get_student_req_dto") GetStudentReqDTO req) {
        return rep.getStudent(req.getId)
    }
    
    @WebMehtod(operationName = "addStudent")
    @WebResult(name="student")
    public Student addStudent(@WebParam(name="add_student_req_dto") AddStudentReqDTO req) {
        return rep.addStudent(req.getName, req.getGroup, ...);
    }
    @WebMehtod(operationName = "updateStudent")
    @WebResult(name="student")
    public Student updateStudent(@WebParam(name="update_student_req_dto") UpdateStudentReqDTO
                                         req) {
        return rep.updateStudent(req.getId, req.getName, req.getGroup, ...);
    }
    //... 
}
```

### Вариант 9

#### 1. Основные проблема коммуникации микросервисов и способы их решения

Проблемы:
- Проблема доступности. Мы не знаем, какой из микросервисов сейчас доступен для общения, а какой упал или потерял коннект.
- Задержка передачи, потери, дублирование пакетов. Мы думаем, что отправили пакет, но получатель его не принял или получил в двойном экземпляре, и нам об этом неизвестно.
- Нагрузка на трафик и память. Сервисы бывают нагруженные, поэтому общение приходится оптимизировать. От этого все становится сложнее. Если использовать какие-то асинхронные системы общения, придется хранить информацию какое-то время, а значит появляется вопрос к утилизации памяти или диска.
- Отказоустойчивость. Часто бывает, что сервисы падают каскадом - один упал, запросы не обрабатывает. Вслед за ним валятся другие сервисы, которые его вызывали - все от того, что они не могут получить ответ на свой запрос.

Решения:

Асинхронные способы общения - мы отправляем сообщение, а ответ придет когда-нибудь потом или он в принципе не предусмотрен:

Месседжинг - RabbitMQ, ZeroMQ, ActiveMQ, Kafka. По сути берут на себя ответственность за доставку сообщения. Также Мессенджинги могут быть с балансировкой нагрузки.

Синхронные способы общения - мы делаем вызов и ждем получения ответа:

REST API - неплохое решение, когда нет высоких нагрузок и получается хорошо контролировать доступность микросервисов. Взаимодействия по REST API проще отслеживать, чем асинхронный обмен, - сразу видно, что ответ не приходит или приходит не в том формате.

Минусы: Если какой-то простой batch должен передать сообщение и завершиться, но получатель лежит, будут проблемы

#### 2. Circuit Breaker. Принципы, реализация, примеры использования.

- ПО, предотвращающее “заведомо обречённые” запросы к сервисам.
- “Каноничный” вариант -- Hystrix из стека Netflix.
- Конфигурируется аннотациями (пример для Hystrix):
  - @EnableCircuitBreaker - разрешить имплементацию CircuitBreaker
  - @EnableHystrix enables Hystrix capabilities in your Spring Boot application
  - @EnableHystrixDashboard - will give a dashboard view of Hystrix stream.
  - @HystrixCommand(fallbackMethod = "myFallbackMethod").

В отличии от Retry (когда если маленький шанс, что ошибка возникнет снова - мы не выбрасываем ошибку) паттерна, паттерн Circuit Breaker рассчитан на менее ожидаемые ошибки, которые могут длиться намного дольше: обрыв сети, отказ сервиса, оборудования. В этих ситуациях при повторной попытке отправить аналогичный запрос с большой долей вероятности мы получим аналогичную ошибку.

Например, приложение взаимодействует с неким сервисом, и в рамках реализации запросов и ответов предусмотрен некоторый тайм-аут, по истечении которого, если от сервиса не получен ответ, то операция считается неуспешной. В случае проблем с этим сервисом, во время ожидания ответа и до достижения тайм-аута приложение может потреблять какие- критически важные ресурсы (память, процессорное время), которые скорее всего нужны другим частям приложения. В такой ситуации, для приложения будет предпочтительнее завершить операцию с ошибкой сразу, не дожидаясь тайм-аута от сервиса и повторять попытку только тогда, когда вероятность успешного завершения будет достаточно высока.

![](./pic/Rubiesh2-6.png)

#### 3. JAX-WS сервис по управлению авиаперелётами

```java
import javax.jws.WebService;
import javax.jws.WebMethod;
import javax.jws.WebParam;

@WebService(name = "FlightService")
public class FlightService {
    @WebMethod
    public List<Flight> getFlights() {
        // Реализация метода
    }

    @WebMethod
    public void addFlight(@WebParam(name = "flight") Flight flight) {
        // Реализация метода
    }

    @WebMethod
    public void deleteFlight(@WebParam(name = "flight") Flight flight) {
        // Реализация метода
    }

    @WebMethod
    public List<Airport> getAirports() {
        // Реализация метода
    }

    @WebMethod
    public void addAirport(@WebParam(name = "airport") Airport airport) {
        // Реализация метода
    }
    
    @WebMethod
    public void deleteAirport(@WebParam(name = "airport") Airport airport) {
        // Реализация метода
    }
}
```

### Вариант 10

#### 1. Load Balancer в Spring Cloud.

Библиотека Spring Cloud Load Balancer позволяет нам создавать приложения, которые взаимодействуют с другими приложениями с балансировкой нагрузки . Используя любой алгоритм, который мы хотим, мы можем легко реализовать балансировку нагрузки при выполнении удаленных вызовов службы.

Load Balancer в Spring Cloud предоставляет возможность распределения нагрузки между несколькими экземплярами служб или приложений. Он поддерживает различные алгоритмы балансировки, включая балансировку по нагрузке, балансировку по расстоянию и балансировку рандомом. Он может использоваться для маршрутизации трафика в микросервисных архитектурах. Это помогает избежать перегрузки одного экземпляра, а также снизить время отклика. Он также предлагает маршрутизацию по меткам (применяемым к отдельным экземплярам служб) и равномерное распределение нагрузки между ними.

Для использования Load Balancer в Spring Cloud необходимо иметь следующие компоненты:
1. Клиентское приложение, использующее балансировщик нагрузки для отправки запросов на сервер.
2. Сервер, который принимает запросы и отправляет ответы клиентскому приложению.
3. Фронт-контроллер, который отвечает за обработку запросов и управляет потоком трафика между клиентом и сервером.
4. Алгоритм балансировки, который определяет, какие серверы будут использоваться для обработки запросов и каким образом будет происходить маршрутизация трафика.

Spring Cloud предоставляет Load Balancer:
1. Ribbon – это клиентский Load Balancer, который помогает приложениям маршрутизировать запросы к доступным службам.


#### 2. Mule ESB, основные свойства и понятия.

Mule ESB - реализация сервисной шины. Сервисная шина предприятия (Enterprise Service Bus, ESB) — ПО, обеспечивающее обмен сообщениями между различными ИС на принципах СОА.

Возможности ESB
- Синхронный и асинхронный вызов сервисов.
- Использование защищённого транспорта, с гарантированной доставкой сообщений, поддерживающего транзакционную модель.
- Маршрутизация сообщений.
- Доступ к данным из сторонних ИС с помощью адаптеров.
- Обработка и преобразование сообщений.
- Оркестровка и хореография сервисов.
- Разнообразные механизмы контроля и управления (аудиты, протоколирование).

Mule ESB - платформа, одна из реализаций ESB, дающая возможность объединять различные информационные системы на основе принципов обмена сообщениями, контроля надежности, сопоставления данных, оркестровки, а также масштабированием между узлами.

Mule ESB

- Платформа ESB и фреймворк для интеграции сервисов от MuleSoft.
- Написана на Java, может выступать в качестве брокера и для сервисов на других платформах.
- Есть открытая и коммерческая версии.
- Есть адаптеры для разных видов сервисов.
- Есть Anypoint Studio – IDE на базе Eclipse для разработки проектов на базе Mule.

Mule: основные понятия

- Каждое сообщение (message) делится на две части – заголовок (header) и полезную нагрузку (payload).
- Обмен сообщениями реализуется через потоки (flows). Каждое приложение содержит один или несколько потоков.
- Есть два способа конфигурации потоков:
  - Через дескрипторы XML.
  - Графический – с помощью Anypoint Studio.


#### 3. Конфигурация на Consul пула серверов WildFly, на которых развёрнута Jakarta EE система по выпеканию пирожков.

```json
{
  "services": [{
    "name": "wildfly-bakery-1",
    "address": "14.88.228.42",
    "port": "14141",
    "checks": [{
      "id": "bakery-1-check",
      "name": "Bakery 1 HTTP check",
      "http": "http://14.88.228.42/14141",
      "method": "GET",
      "interval": "14s"
    }]
  },{
    "name": "wildfly-bakery-2",
    "address": "14.88.228.24",
    "port": "14141",
    "checks": [{
      "id": "bakery-2-check",
      "name": "Bakery 2 script check",
      "script": "/petuxon.py --host 14.88.228.24 -- port 14141",
      "interval": "88s"
    }]
  }]
}
```

### Вариант 11

#### 1. Оркестровка и хореография микросервисов

Оба термина описывают два аспекта разработки бизнес-процессов на основе объединения Web-сервисов.

Оркестровка микросервисов – добавление подсистемы (дирижер - orchestrator), которая будет координировать взаимодействие между сервисами:

![](./pic/Rubiesh2-7.png)

При оркестровке мы настраиваем и интегрируем существующие микросервисы для реализации бизнес-целей (в т.ч. планирование распределенной системы, интеграцию существующих микросервисов, обновление микросервисов и мониторинг производительности).

- Добавляется подсистема, которая координирует взаимодействие между сервисами (“дирижёр” – Orchestrator).
- Есть готовые решения для оркестровки микросервисов:
  - Kubernetes;
  - Azure Kubernetes Service (ACS);
  - Apache Mesos;
  - Amazon Elastic Container Service (ECS).

Хореография микросервисов – это процесс проектирования связи между микросервисами и их взаимодействий. Она может включать в себя проектирование архитектуры, создание мостов между микросервисами, планирование взаимодействия между микросервисами и мониторинг и анализ межсервисной связи. В отличие от оркестровки “центрального” сервиса нет: Административная логика “размазана” по сервисам:

Хореография более честно ложится на Микросервисную архитектуру, но сложнее в реализации. Для имплементации могут использоваться брокеры событий

#### 2. Top-down и bottom-up стратегии при использовании аннотаций wsdl

Top-down стратегия включает в себя создание WSDL-документа, используя в качестве основы схему XML. Процесс предполагает использование аннотаций, таких как `@WebService` и `@WebMethod`, для определения интерфейса web-службы. 

Bottom-up стратегия предполагает начало с существующего WSDL-документа. Для реализации данной стратегии используется `@WebServiceProvider` аннотация для создания интерфейса web-службы.

Top-down стратегия предполагает сначала создание WSDL-документа и затем использование его для генерации кода. Это полезно, когда вам нужно предоставить доступ к вашим службам другим людям, которые не знакомы с вашим кодом.

Bottom-up стратегия предполагает сначала создание кода и затем генерацию WSDL-документа на основе этого кода. Это полезно, когда вы создаете службы для использования ими других людей, но вы остаетесь ответственным за их реализацию

#### 3. Конфигурация Spring Boot сервиса для подключения Consul, он живет на localhost на 8500 порту

```properties
spring.application.name=main-service
spring.cloud.consul.host=localhost
spring.cloud.consul.port=8500
spring.cloud.consul.config.enabled=true
#health check
spring.cloud.consul.config.import-check.enabled=false
spring.cloud.consul.discovery.health-check-path=/health
spring.cloud.consul.discovery.health-check-interval=8s
#if tls cert self-signed
spring.cloud.consul.discovery.health-check-tls-skip-verify=true
#if https needed
spring.cloud.consul.discovery.scheme=https
```

### Вариант 12

#### 1. Свойства и ключевые особенности микросервиса.

Это архитектурный стиль разработки, который позволяет создавать приложения в виде набора небольших автономных микросервисов, разработанных для бизнес-сферы.

Особенности MSA

- Модули легко заменить в любое время: акцент на простоту, независимость развёртывания и обновления.
- Микросервис [по возможности] выполняет только одну элементарную функцию.
- Модули могут быть реализованы с использованием разных стеков технологий и работать на разных платформах.
- Архитектура симметричная, а не иерархическая: зависимости между микросервисами одноранговые.

Свойства микросервиса

1. Небольшой
2. Независимый.
3. Строится вокруг бизнес-потребности и использует ограниченный контекст (Bounded Context).
4. Взаимодействует с другими микросервисами по сети на основе паттерна Smart endpoints & dumb pipes.
5. Его распределенная суть обязывает использовать подход Design for failure.
6. Централизация ограничена сверху на минимуме.
7. Процессы его разработки и поддержки требуют автоматизации.
8. Его развитие итерационное.

Что значит “небольшой”?

- Один сервис может развивать одна команда не более чем из дюжины человек.
- Команда из полудюжины человек может развивать полдюжины сервисов.
- Контекст (не только бизнеса, но и разработки) одного сервиса помещается в голове одного человека.
- Один сервис может быть полностью переписан одной командой за одну Agile-итерацию.

Что значит “независимый”?

- Использует свой контекст.
- Не использует [общие] библиотеки.
- Использует своё хранилище данных (!).
- Следствие независимости – при большом числе сервисов требуются продвинутые инструменты CI и CD.

#### 2. Структура документа WSDL

- WSDL - Язык спецификации SOAP веб-сервисов, который Базируется на XML.
- Базируется на XML.
- Описывает весь интерфейс сервиса:
  - функции;
  - аргументы;
  - возвращаемые значения.
- Может автогенерироваться по API сервиса, или, наоборот – API сервиса может автогенерироваться по WSDL.

Структура версии 1.1:

Abstract Definition of Service
- Types: Данный раздел содержит определения типов данных для описания входных/выходных параметров службы: вида отправляемых и получаемых сервисом XML-сообщений
- Messages: Данный раздел содержит определения сообщений, которые будут отправляться и получаться в рамках вызова службы. То есть это описание элементов данных.
- Port Types - абстрактные операции: Данный раздел содержит определения интерфейсов служб, содержащие информацию об операциях, принимаемых службой над сообщениями, и о последовательности, в которой должны быть вызваны эти операции. Protocol and physical locations
- Bindings (связывание сервисов) — способ, которым сообщение будет доставлено.
- Service ports - где сервис расположен

Структура документа WSDL 1.1, пример:

![](./pic/Rubiesh2-9.png)

Отличия WSDL 2.0 от 1.1:
- Типы портов переименованы в интерфейсы. Поддержка наследования интерфейса достигается за счет использования атрибута extends в элементе интерфейса.
- Порты переименованы в конечные точки

![](./pic/Rubiesh2-10.png)

#### 3. Конфигурация, регистрирующая в Consul пул экземпляров СУБД MySQL. Сервисы расположены на машинах ra, helios и anubis, экземпляры занимают порт 3306 на каждой из машин. Конфигурация должна обеспечивать проверку того, запущены ли экземпляры каждого из сервисов.

```json
{
  "services": [{
    "name": "mysql-ra",
    "address": "ra-address",
    "port": "3306",
    "checks": [{
      "name": "RA MySQL check",
      "script": "/mysql-check-script.py --host ra-address -- port 3306",
      "interval": "88s"
    }]
  },{
    "name": "mysql-helios",
    "address": "helios.se.ifmo.ru",
    "port": "3306",
    "checks": [{
      "name": "Helios MySQL check",
      "script": "/mysql-check-script.py --host helios.se.ifmo.ru -- port 3306",
      "interval": "88s"
    }]
  }, {
    "name": "mysql-anubis",
    "address": "anubis-address",
    "port": "3306",
    "checks": [{
      "name": "Anubis MySQL check",
      "script": "/mysql-check-script.py --host anubis-address -- port 3306",
      "interval": "88s"
    }]
  }]
}
```

### Вариант 13

#### 1. Преимущества и недостатки MSA по сравнению с “обычной” SOA.

Преимущества МСА по сравнению с СОА:
- Уменьшение размера кода: МСА может быть более легкой и модульной архитектурой, поскольку она может быть ориентирована на компоненты и более маленькие микросервисы.
- Легче реализовывать масштабирование: МСА может быть легко масштабируемой архитектурой, поскольку она может быть разделена на множество маленьких и модульных компонентов.
- Ускорение разработки: Для создания и поддержания приложений в рамках МСА можно использовать более легкие инструменты и фреймворки.

Недостатки МСА по сравнению с СОА:
- Потенциальные проблемы с согласованностью данных: В некоторых случаях возникает проблема установления согласованности данных по всем микросервисам.
- Отсутствие поддержки для платформы: В некоторых случаях микросервисы могут быть сложно портировать на новые платформы.
- Потенциальные проблемы с безопасностью: В некоторых случаях возникают проблемы с безопасностью, поскольку для некоторых приложений требуется более высокий уровень безопасности, чем тот, который предоставляется в рамках МСА.

Преимущества микросервисов
- Более простой шаблон архитектуры, который легко понять разработчикам
- IDE быстрее делает разработчиков быстрее и продуктивнее
- Веб-контейнер запускается быстрее; это помогает ускорить процесс развертывания и разработки.
- Это позволяет команде разрабатывать, развертывать и масштабировать свой сервис независимо от всех других команд.

Недостатки микросервисов
- Он разработан для построения монолитных приложений, поэтому он не предоставляет явной поддержки для разработки распределенных приложений.
- Тестирование сложнее
- Разработчики должны реализовать механизм
- межсервисных коммуникаций.
- Реализация вариантов использования, охватывающих несколько служб, требует координации между командами.
- Микросервис стоит дорого, так как вам всегда нужно поддерживать различное серверное пространство для разных бизнес-задач

#### 2. Аннотации JAX-WS

- `@WebService` — указывает на то, что Java класс (или интерфейс) является веб-сервисом.
- `@WebMethod` — позволяет настроить то, как будет отображаться метод класса на операцию сервиса.
- @WebParam — позволяет настроить то, как будет отображаться конкретный параметр операции на WSDL-часть (part) и XML элемент.
- `@WebResult` — позволяет настроить то, как будет отображаться возвращаемое значение операции на WSDL-часть (part) и XML элемент.
- `@Oneway` — указывает на то, что операция является односторонней, то есть не имеет выходных параметров.
- `@SOAPBinding` — позволяет настроить то, как будет отображаться сервис на протокол SOAP. 

#### 3. Конфигурация, регистрирующая в Consul пул сервисов libreoffice … обработкой документов. Сервисы расположены на машинах aqua, …, по пути /usr/bin/soffice. Конфигурация должна обеспечивать проверку запущены ли экземпляры сервисов.

```json
{
  "service": {
    "name": "libreoffice-service",
    "port": 8080,
    "check": {
      "script": "curl helios:8080/health",
      "interval": "10s"
    },
    "tags": ["libreoffice", "documents"],
    "enable_tag_override": false
  },
  "checks": [
    {
      "id": "libreoffice-service-1",
      "name": "Libreoffice service on aqua",
      "command": "/usr/bin/soffice",
      "args": ["--listen",
        "--accept=socket,host=aqua,port=8080"],
      "interval": "10s"
    },
    {
      "id": "libreoffice-service-2",
      "name": "Libreoffice service on terra",
      "command": "/usr/bin/soffice",
      "args": ["--listen",
        "--accept=socket,host=terra,port=8080"],
      "interval": "10s"
    }
  ]
}
```

### Вариант 14

#### 1. UDDI

UDDI: Universal Description, Discovery and Integration — централизованное хранилище дескрипторов WSDL со стандартизированным API. Спецификация UDDI задает способ публикации Web-служб и поиска информации о них.

Спецификация UDDI выполняет две функции:
- Она представляет собой протокол на основе SOAP, описывающий способ взаимодействия клиентов с реестрами UDDI.
- Она выполняет роль набора реестров с глобальной репликацией.

Структура UDDI состоит из:
- Белые страницы - адрес, контакты и известные идентификаторы;
- Желтые страницы - категоризация, описание возможностей, разбиение по географии;
- Зеленые страницы - техническая информация о сервисе: интерфейсы, API.

В состав UDDI входит схема XML для сообщений SOAP, в которой задан набор документов с описанием бизнес-записей и служб, общий набор API для поиска и публикации информации в каталогах, а также API для репликации записей каталогов между равноправными узлами UDDI.

UDDI управляет поиском Web-служб в распределенном реестре бизнес-записей и связанных описаний служб в общем формате XML. Перед публикацией бизнес-объекта и Web-службы в общедоступном реестре необходимо зарегистрировать бизнес-объект в реестре UDDI.

#### 2. Design for failure

Design for Failure - Одно из ключевых свойств микросервисной архитектуры. У MSA есть ряд проблем:

- Ненадёжность сети (а практически все вызовы -- удалённые!).
- Сложность реализации событийной архитектуры.

Эти проблемы сложно и дорого устранять, поэтому мы считаем, что наличие некритичных ошибок при работе -- нормальная ситуация. Свойство же design for failure заключается в том, что с самого первого этапа, начиная строить микросервисную архитектуру, вы должны исходить из предположения, что ваши сервисы не работают. Другими словами, ваш сервис должен понимать, что ему могут не ответить никогда, если он ожидает каких-то данных. Таким образом, вы сразу должны исходить из ситуации, что что-то у вас может не работать.

При этом повышаются требования к инфраструктуре: мы должны уметь оперативно выявлять и исправлять проблемы.

Например, для этого компания Netflix разработала Chaos Monkey — инструмент, который ломает сервисы, хаотически их выключает и рвет соединения. Этот нужно, чтобы оценить надежность системы.

#### 3. конфиг для консула чтобы зарегать 3 бд

```json
{
  "services": [
    {
      "name": "mysql-service",
      "address": "mysql-address",
      "port": "1010",
      "checks": [
        {
          "name": "check is mysql alive",
          "script": "/check-is-alive.py --host mysql-address --port 1010",
          "interval": "20s"
        }
      ]
    },
    {
      "name": "postgresql-service",
      "address": "postgresql-address",
      "port": "1010",
      "checks": [
        {
          "name": "check is postgresql alive",
          "script": "/check-is-alive.py --host postgresql-address --port 1010",
          "interval": "20s"
        }
      ]
    },
    {
      "name": "redis-service",
      "address": "redis-address",
      "port": "1010",
      "checks": [
        {
          "name": "check is redis alive",
          "script": "/check-is-alive.py --host redis-address --port 1010",
          "interval": "20s"
        }
      ]
    }
  ]
}

```

### Вариант 15

#### 1. Service Discovery в решениях на базе Spring Cloud Netflix

Spring Cloud Netflix -- бандл для построения СОА систем на базе Spring Cloud Netflix и интеграции его в стек Netflix OSS посредством автоматической настройки и привязки к Spring Environment. Шаблоны внутри приложения настраиваются легко и быстро с помощью нескольких простых аннотаций, тем самым позволяя создать большие распределенные системы с проверенными в бою компонентами Netflix. Spring Cloud Netflix предоставляет client-side SD - Eureka.s

Напомним, что client-side discovery - клиент запрашивает информацию о доступе к доступным экземплярам у SD, а дальше сам распределяет нагрузку между ними. В Client-side SD единственной «фиксированной точкой» в архитектуре является Service Registry, в котором должна регистрироваться каждая служба. Клиент сам имплементирует логику для взаимодействия со службой.

Каждый микросервис регистрируется на сервере Eureka, и Eureka знает все клиентские приложения, работающие на каждом порту и IP-адресе. Eureka Server также известен как Discovery Server.

С Netflix Eureka каждый клиент действует как “сервер” при подключении к сервису: клиент извлекает список всех подключенных экземпляров в service registry и отправляет все дальнейшие запросы к службам с помощью алгоритма балансировки нагрузки.

Обязанность Eureka — давать имена каждому микросервису. Эврика регистрирует микросервисы и отдает их ip другим микросервисам. Таким образом, каждый сервис регистрируется в Eureka и отправляет эхо-запрос серверу Eureka, чтобы сообщить, что он активен. Для этого сервис должен быть помечен как `@EnableEurekaClient`, а сервер `@EnableEurekaServer`.


#### 2. Сервисные шины особенности, преимущества и недостатки, использование в решениях на базе SOA

Основным направлением архитектуры ESB является разделение систем друг от друга и обеспечение их устойчивой и управляемой связи.

Cостав ESB:
- Брокер сообщений — обеспечивает управление очередностью сообщений и выступает посредником между приложением-источником и приложением-приемником;
- Комплект адаптеров — программных компонентов, которые служат для связи приложений с ESB и преобразуют один интерфейс в другой. Чем больше различных адаптеров заложено в интеграционную шину, тем шире ее функционал;
- В современных ESB-решениях реализованы принципы микросервисной архитектуры. В соответствии с ними весь функционал системы распределяется между микросервисами, каждый из которых может работать независимо от других;
- Средства для контроля и мониторинга.

Преимущества:
- Через интеграционный шлюз происходит быстрый обмен данными с использованием разных форматов и протоколов.
- ESB позволяет преобразовать сообщения в нужный формат, контролировать транзакции, проводить маршрутизацию с учетом смысла, равномерно распределять нагрузку на отдельные сервисы и гарантировать безопасность обмена данными

Недостатки:
- Сложность реализации
- Требует больших ресурсов.

Mule(см. [Вариант 10 вопрос 2](#2-mule-esb-основные-свойства-и-понятия))

#### 3. Набор микросервисов на Spring MVC, реализующий параллельную сортировку элементов массива. Алгоритм сортировки мож но выбрать любой подходящий.

Похоже на [вариант 4. Вопрос 3](#3-набор-микросервисов-на-spring-mvc-управляющий-распределением-по-аудиториям-и-преподавателям-студентов-ожидающих-своей-очереди-на-доп-должна-поддерживаться-возможность-добавления-новых-аудиторий-и-преподавателей-и-удаления-существующих-в-одной-аудитории-может-находиться-более-одного-преподавателя) (потому что тоже именно набор микросервисов, а не 1 микр.,/осервис)