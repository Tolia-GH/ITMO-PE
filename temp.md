0:08
сегодня мы рассмотрим базовую задачу
0:12
компьютерного зрения которая имеет на
0:14
данный момент пожалуй самый широкий
0:17
спектр применения в промышленности в
0:20
данной лекции мы поговорим о
0:23
детектировании объектов формальная
0:26
постановка данной задачи выглядит
0:28
следующим образом для входной фотографии
0:31
и некоторого списка детектирует их
0:34
классов объектов которые нам задан
0:37
набором примеров изображений для каждого
0:40
класса нам необходимо определить
0:42
координаты позиции в пикселах разумеется
0:45
охватывающего прямоугольника для каждого
0:48
присутствия объекта каждого детектирует
0:51
было класса на входном изображение
0:53
сделаем некоторые оговорки насчет
0:57
постановки иногда помимо самих балдин
1:00
боксов и классов требуется выдавать
1:03
некоторое подобие вероятности
1:05
уверенность нахождение объекта
1:08
определенного класса в этом балдин боксе
1:10
то есть вещественное число от нуля до
1:14
единицы
1:15
сделаем вторую оговорку в большинстве
1:18
случаев охватывающий прямоугольники
1:21
параллельны осям координат изображения
1:23
однако в некоторых случаях охватывающие
1:27
четырехугольники могут быть не
1:29
прямоугольными более того чаще всего
1:32
примеры объектов каждого класса
1:34
сдаются в формате набора изображений и
1:38
аннотации которая совпадает с идеальным
1:41
ответом детектора для этого изображения
1:43
и установленного набора классов
1:46
да булма глубоких нейронных архитектур
1:49
задачи компьютерного зрения все подходы
1:52
применяемые при решении реальных задач в
1:55
промышленности как правило сводились к
1:57
одной и той же схеме определялась
1:59
область наиболее вероятном нахождением
2:02
объектов с помощью каких либо эвристик
2:05
или априорные разметки на этапе
2:07
калибровки системы после чего на данные
2:10
области проходились сканирующим окном
2:12
различных форм и размеров
2:15
затем на участки изображения
2:17
ограниченным окном запускались
2:20
классификаторы
2:21
определяющие вероятность нахождения
2:23
объекта
2:24
определенного класса в данном регионе
2:27
ограниченным охватывающим окном на
2:30
заключительной стадии производилась
2:32
некоторая постобработка ходе которой
2:35
происходило объединение уточнения бокс
2:38
а также уточнения списка зафиксированных
2:42
объектов конечно классическая схема
2:45
детектора описано довольно друга
2:48
активно применялись многочисленные
2:50
оптимизации такие как совмещение стадии
2:53
работы общего алгоритма а также
2:56
различные вариации пирамидальной
2:59
обработки и использования уже полученных
3:02
результатов классификации
3:04
на уже обработанных сканирующим окном
3:07
участках входного изображения виду не
3:10
оптимальности и несопоставимых лучшими
3:13
результатами работы на открытых наборах
3:16
данных
3:16
особенно в случае много- класса
3:19
детектирования
3:20
мы не будем долго останавливаться на
3:23
подходах
3:23
не использующих глубокие нейросетевые
3:26
архитектуры рассмотрим пожалуй самый
3:29
известный классический алгоритм
3:31
детектирование рис который долгое время
3:33
работал почти во всех цифровых
3:36
фотоаппаратах использующих функционал
3:39
поиска человеческих лиц итак метод виолы
3:43
джонса
3:44
позволяет обнаруживать объекты на
3:46
изображениях в реальном времени
3:49
хотя данный алгоритм может распознавать
3:52
объекты любой природы основной задачей
3:56
при его создании было обнаружение
3:58
человеческих лиц в основе алгоритма
4:01
лежит идея построения сильного
4:03
классификатора с помощью каскада слабых
4:06
каждый из которых основан на
4:09
использовании специального признака
4:11
некоторого подобия ядра свертки слабые
4:14
классификаторы
4:15
объединяются во взвешенную сумму общая
4:18
схема обучается с помощью у стинга
4:21
признаки используемые алгоритмом
4:24
опираются на суммирование пикселов
4:26
из прямоугольных регионов сами признаки
4:29
несколько напоминают признаки хаора
4:32
которые ранее также использовались для
4:35
поиска объектов на изображении
4:37
однако признаки из алгоритма виолы
4:40
джонса содержит более 1 прямоугольной
4:43
области и несколько сложнее на
4:46
иллюстрации справа показана четыре
4:49
различных типа признаков величина
4:51
каждого признака вычисляется как сумма
4:54
пикселов в белых прямоугольниках из
4:57
которой
4:58
вычитается сумма пикселов в черных
5:01
областях
5:02
прямоугольные признаки довольно
5:04
примитивны и несмотря на то что они
5:07
чувствительны к вертикальным и
5:08
горизонтальным особенностям изображений
5:11
результат поиска
5:13
фрагмента с их помощью довольно груб
5:16
однако при хранении изображений в
5:19
интегральном формате это когда в каждом
5:21
пикселе изображение записано сумма всех
5:24
пикселов левее и выше данного проверка
5:27
прямоугольного признака на конкретные
5:30
позиции производится за константное
5:32
время
5:33
что является преимуществом по сравнению
5:36
с более точными вариантами каждая
5:39
прямоугольная область в используемых
5:41
признаках всегда смежно с другими
5:43
прямоугольными областями поэтому расчет
5:46
признака с двумя прямоугольниками
5:48
состоит из шести обращений в
5:51
интегральный массив а для признака с
5:54
тремя прямоугольниками
5:55
из восьми с четырьмя из 9 высокая
5:59
скорость обсчета признаков не
6:00
компенсирует значительное количество
6:03
различных возможных признаков примеру
6:05
при стандартном размере признака в 24 на
6:09
двадцать четыре пикселя возможно 162
6:12
тысячи различных итоговых комбинаций и
6:16
их расчет может занять большое
6:18
количество времени поэтому в подходе
6:22
предложены виолы джонсом используется
6:25
вариация алгоритма обучения ада густо
6:29
как для выбора признаков так и для
6:31
настройки классификаторов
6:34
минусы ада boost заключается в следующем
6:37
иногда возникает переобучение при
6:40
наличии значительного уровня шума в
6:42
данных экспоненциальная функция потери
6:45
слишком сильно увеличивает веса наиболее
6:48
трудных объектов на которых ошибаются
6:51
многие базовые алгоритмы
6:53
однако именно эти объекты чаще всего
6:56
оказываются шумовыми выбор сами в
6:59
результате
7:00
адабу ст начинает настраивается на шум
7:03
что ведет к переобучению
7:06
проблема решается путем удаления
7:08
выбросов или применения
7:10
меня агрессивных функций потерь в
7:13
частности применяется алгоритм gentoo
7:16
boost
7:17
а до boost требует достаточно длинных
7:19
обучающих выборок другие методы линейных
7:22
коррекции в частности backing способны
7:25
строить алгоритмы сопоставимого качества
7:27
поменьше выборкам данных бывает
7:30
построение не оптимального набора
7:32
базовых алгоритмов для обучения
7:35
композиции можно периодически
7:37
возвращаться к ранее построенным
7:39
алгоритмам и обучать их заново гус-ting
7:42
может приводить построению громоздких
7:45
композиций состоящих из сотен алгоритмов
7:48
такие композиции
7:50
исключают возможность содержательной
7:52
интерпретации требует больших объемов
7:55
памяти для хранения базовых алгоритмов и
7:57
существенных временных затрат на
8:00
вычисления классификаций
