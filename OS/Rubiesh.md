# Rubiesh

## 1

Дисковый массив с уровнем рейда RAID-{A} состоит из {B} дисков по {C} гибибайт с блоками по {D} байт. Размер страйп-unit составляет {Е} блоков. Средняя скорость одной операции чтения блока данных при последовательном доступе к диску равна {F} мкс, а записи {G} мкс;  
RAID 级别 RAID-{A} 的磁盘阵列由 {B} 个 {C} 吉比字节的磁盘和 {D} 个字节的块组成。 条带单元的大小为{E}块。 磁盘顺序访问时数据块一次读操作的平均速度为{F}μs，写入速度为{G}μs；

Скорость вычислений корректирующих кодов для одного страйп-unit данных составляет {H} мкс.  
计算一个数据条带单元的校正码的速度为{H}μs。

При замене одного диска, сколько будет восстанавливаться диск в минутах? Считать, что для восстановления диска нужно обработать все блоки целиком.  
更换一块磁盘时，需要多长时间才能恢复磁盘（以分钟为单位）？ 考虑一下要恢复磁盘，您需要完全处理所有块。

> A=5, B=4, C = 2048, D = 512, E = 16, F = 6, G = 15. H = 256

![](./pic/Rubiesh1-1.png)

RAID-5
4 диска по 2048 ГиБ
блок = 512 байт
\$stripe_unit = 16 блоков
read блока = 6 мкс
write в блок = 15 мкс
вычисления для одного SU = 256 мкс

RAID-5 使用奇偶校验来实现冗余。在一个RAID-5磁盘阵列中，数据条带单元包含多个数据单元和一个校验单元，校验单元用于存储奇偶校验信息。在磁盘损坏的情况下，通过校验单元的信息可以恢复丢失的数据单元。

如上图 RAID 5 所示，假如 Disk3 损坏，需要恢复 Disk 3 的数据。对于每一行的 strike 单元（以A_p为例），我们需要依次读取单元 A1， A2， A3，然后进行奇偶校验计算，然后写入 Disk3 的 A_p 单元，（同理对于 B_3）,我们需要依次读取单元 B1， B2， B_p，然后进行奇偶校验计算，然后写入 Disk3 的 B_3 单元，以此类推，最后恢复整个 Disk3 的数据

![](./pic/Rubiesh1-2.png)

1) Определяем размер диска в байтах:  
   确定磁盘大小（以字节为单位）：  
    \$disk_size = 2048 * 1024 * 1024 * 1024 = 2199023255552

2) Определяем количество stripe-unit'ов на диске (эквивалентно количеству LV aka stripe'ов):  
   确定磁盘上条带单元的数量（相当于 LV 又名条带的数量）：  
    \$stripes = \$disk_size / (512 * 16) = 268435456

3) Определяем количество блоков на диске:  
   确定磁盘上的块数：  
    \$block_count = (2048 * 1024 * 1024 * 1024) / 512 = 4294967296

Теперь считаем время (чтение с соседей + вычисление + запись):  
现在我们计算时间（读取邻居+计算+写入）：

1) Сколько нам придется писать в блоки:  
   写入所需的时间：  
    \$write_time = \$block_count * 15 мкс = 64424509440 мкс

2) Сколько нам придется считать:  
   奇偶校验计算所需的时间  
    \$calculate_time = \$stripes * 256 мкс = 68719476736 мкс

3) Сколько нам придется читать (с условием, что с соседних дисков читаем параллельно):  
   读取所需的时间（并行读取，因此只需要计算读取一个盘所需的时间）  
    \$read_time = \$block_count * 6 мкс = 25769803776 мкс

4) Итого: 总时间
    **\$answer = \$read_time + \$calculate_time + \$write_time**  
    **= 158913789952 мкс / (60 * 10^6) = 2648,56 мин ≈ 2649 мин**

而对于 RAID-6 的磁盘阵列，以上图为例，由 5 个磁盘组成。对于每一行的单元（以第一行为例），A1，A2，A3 为数据单元，A_p 由 A1，A2，A3 经过计算得出，A_q 由 A1，A2，A3 经过另一种方式计算得出，因此 RAID6 可以在两个硬盘损坏的情况下依然能恢复所有数据（但是计算过程很复杂，这里没有进行详细研究），而对于只有一个硬盘需要恢复的情况，计算方式同 RAID 5（并行读取 3 个硬盘的所有 block，进行校验计算， 然后写入需要恢复的硬盘）

## 2

B Unix-подобной файловой системе в inode содержится {А} указателей на прямые блоки файла, каждый из которых занимает {B} бит, при необходимости используется фиксированное группирование записей в блоке. Размер логического блока файловой системы составляет {С} байт.

Каково общее количество блоков (включая служебные) будет занимать файл длинной {D} байт?