# Архитектура компьютера

## Лекция 9

### Процессор фон Неймана и его вариации. Гарвард. CISC

Пенской А.В., 2022

----

### План лекции

- Пример машины фон Неймана
- Машина фон Неймана и её вариации:
    - Способы обращения к данным
    - Организация памяти программ и данных
    - Системы команд и их особенности
        - Complex Instruction Set Computer (CISC). Control Unit и DataPath. Микрокод

---

### Устройство. Control Unit и DataPath (повтор)

<div class="row"><div class="col">

![](../fig/von-neumann.png)

</div><div class="col">

![](../fig/proc-control-unit-and-datapath.jpg)

</div></div>

----

### Проблемы проектирования ISA для процессора фон Неймана (повтор)

1. Типы данных и их размеры (бит, кодирование, тегирование).
2. Набор команд и их взаимозаменяемость.
3. Количество операндов (1, 2 и более).
4. Расположение операндов и результата. Адресация.

<div class="row"><div class="col">

- Подразумеваемый адрес <br/> (часть Opcode)
- Непосредственная адресация (hardcode)
- Прямая адресация <br/> (указывается числом)
- Относительная (базовая) адресация (`addr + base`)

</div><div class="col">

- Укороченная адресация
- Регистровая адресация
- Косвенная адресация
- Адресация слов переменной длины
- Стековая адресация
- Автоинкрементная и автодекрементная

</div></div>
5. Кодирование инструкций. Простота декодирования и компактность.

---

## Пример процессора фон Неймана

![_Пример процессора из семейства фон Неймана_](../fig/von-neumann-example.png)

----

- Разрядность процессора: 8 бит.
- Организация памяти: Гарвардская.
- Внешние устройства отображаются в адресное пространство данных. Работа с ними выполняется по опросу.
- Регистры:
    - `PC` -- счетчик команд
    - `IR` -- регистр инструкций
    - `AR` -- регистр адреса операнда
    - `C` -- флаг переноса/займа
    - `Z` -- флаг нуля
- Команды выполняются за 2 или 3 такта:
    - Выборка команды.
    - Выборка операндов.
    - Выполнение команды.
- Подсистема обработки прерываний и команды вызова подпрограмм отсутствуют.

[Как можно смоделировать такой процессор, описанный выше?](http://amazing-new-gate.blogspot.com/2010/07/haskell.html)

----

### Пример исполнения команды

<div class="row"><div class="col">

![_Пример процессора из семейства фон Неймана_](../fig/von-neumann-example.png)

```text
Add 34 + [03] -> [01] (4 байта)
```

</div><div class="col">

```text
1. Чтение инструкции
  - IR <- PMem[PC]
  - PC <- PC+1
2. Инициализация акк. 34
  - {Acc, Z, C}
    <- АЛУ(...) <- MUX2(...) 
    <- PMem[PC]
  - PC <- PC+1
3. Выгрузка адреса [03]
  - AR <- PMem[PC]
  - PC <- PC+1
4. Выгрузка данных из памяти, +
  - {Acc, Z, C} 
    <- ALU(...) <- MUX2(...)
    <- DMem[AR].DOUT
5. Выгрузка адреса [01]
  - AR <- PMem[PC]
  - PC <- PC+1
6. Сохранение результата
  - DMem[AR].DIN <- Acc
```

</div></div>

---

## Вариации архитектуры (ISA) <br/> фон Неймана

1. Способ обработки данных
2. Организация памяти программ и данных
3. Набор команд:
    - CISC. Hardwired. Microcoded. NISC
    - RISC. Pipelined

Вопросы ввода-вывода, параллелизма уровня инструкций и команд, изоляции процессов, а также иерархия памяти будут рассмотрены позднее.

---

### Способ обработки данных

- Accumulator Architectures
- Register-to-Register Architectures
- Register-to-Memory Architectures
- Memory-to-Memory Architectures

----

![](../fig/proc-accum-arch.png)<!-- .element height="700px" -->

----

![](../fig/proc-reg-to-reg-arch.png)<!-- .element height="700px" -->

----

![](../fig/proc-reg-to-mem-arch.png)<!-- .element height="700px" -->

----

![](../fig/proc-mem-to-mem-arch.png)<!-- .element height="700px" -->

Notes: ECE C61 Computer Architecture Lecture 3 – Instruction Set

---

### Организация памяти программ и данных

![_Гарвардская архитектура_](../fig/von-neuman-vs-harvard-architecture.png)

<div class="row"><div class="col">

Узкое место архитектуры фон Неймана (Принстонская) -- память:

- доступ к инструкциям
- доступ к данным
- неодновременный доступ

</div><div class="col">

Отличие Гарвардской архитектуры:

- хранилище инструкций и хранилище данных -- разные физические устройства
- каналы инструкций и данных физически разделены

</div></div>

----

#### Особенности Гарвардской архитектуры

Достоинства:

- Одновременный доступ к памяти.
- Разные ширины машинного слова и адреса для данных и программ.
    - Оптимизация под решаемую задачу.
    - Данные и память программ всегда перемешаны (к примеру: непосредственная адресация и указатели на функции).
- Два физических канала между процессором и памятью.
- Изоляция памяти инструкций.

Недостатки:

- сложность и стоимость реализации;
- изоляция инструкций и данных.

*Вопрос*: От чего зависит размерность машинных слов и адресных пространств?

----

#### Вариации Гарвардской архитектуры

Архитектура "Память инструкций как данные" <br/> (Instruction-memory-as-data)
: реализуется возможность читать и писать данные в память программ. Позволяет генерировать и запускать машинный код.

Архитектура "Память данных как инструкции" <br/> (Data-memory-as-instruction)
: реализует возможность запуска инструкций из памяти данных. Позволяет генерировать и запускать машинный код, при этом параллельный доступ ограничен.

Модифицированная Гарвардская архитектура (main stream)
: Доступ к памяти реализуется через независимые кеши для данных и программ, за счет чего, с точки зрения внутренней организации процессора, доступ реализован независимо, при этом канал между процессором и памятью один.

---

### Система команд и линейная функции

$Y = A * X + B$

<div class="row"><div class="col">

```text
load R1 <- A
load R2 <- X
load R3 <- B
mul R4 <- R1 * R2
add R5 <- R4 + R3
store Y <- R5
```

</div><div class="col">

```text
load R1 <- A
load R2 <- X
load R3 <- B
lfn R4 <- R1 * R2 + c
store Y <- R4
```

</div></div>

```text
load R1 <- A
mul R1 <- R1 * B
add R1 <- R1 + C
store Y <- R1
```

<div class="row"><div class="col">

```text
mul R1 <- A * B
add Y <- R1 + C
```

</div><div class="col">

```text
lfn Y <- A * B + C
```

</div></div>

*Вопрос*: Какой состав команд лучше и почему?

Notes: зависит от алгоритма, неплохо бы оптимизировать под задачу.

---

## Complex Instruction Set Computer

CISC
: is a computer architecture in which single instructions can execute several low-level operations (a load from memory, an arithmetic operation, and a memory store) or are capable of multi-step operations or addressing modes within single instructions.

<div class="row"><div class="col">

Причины появления:

- Низкоуровневые языки.
- Разнообразие архитектур.
- Неразвитость компиляторов.
- Удобство программирования.
- Высокая производительность.
- Минимизация объёма программ.
- Минимизация накладных расходов.

</div><div class="col">

Проблемы:

- Сложная система команд (использование, анализ).
- Сложное устройство Control Unit и процессора.
- Сложно генерировать эффективный машинный код.

</div></div>

----

### Реализация Control Unit

<div class="row"><div class="col">

Hardwired
: при помощи аппаратных комбинационных схем, декодирующих инструкции в последовательности сигналов.

Microcoded
: при помощи исполнения микропрограммы, реализующей необходимые функции.

Микропрограмма (микрокод)
:  программа, реализующая набор инструкций процессора.

</div><div class="col">

![](../fig/processor-hardwires-and-microcoded.gif)

![Microcode decoding_](../fig/microcode-decode.png)

</div></div>

----

#### Микропрограммное управление

<div class="row"><div class="col">

Достоинства:

1. Простота реализации (CISC).
2. Возможность "программирования" системы команд.
3. Доступ к микрокоду для программиста.
4. Генерация ISA под задачу (сократить объём, повысить эффективность), см. [УВК «Самсон» -- базовая ЭВМ РВСН](https://www.computer-museum.ru/articles/sistemi_kompleksi/90/).

</div><div class="col">

Недостатки:

1. Хранение микрокода в процессоре.
2. CISC требует знаний.
3. Разнообразие архитектур = проблемы инструментария.
4. Разнообразие команд (форматы, размеры, длительности, доступ). Усложняет:
    - оптимизацию процессора;
    - инструментарий.
5. Микрокод привносит все проблемы программирования (сложность, отладка, методы).

</div></div>

----

#### No Instruction Set Computing (NISC)

<div class="row"><div class="col">

![_CISC with microcode_](../fig/cisc.png)

</div><div class="col">

![_NISC_](../fig/nisc.png)

</div></div>

----

##### Особенности NISC

1. Убрать ISA как уровень абстракции:
    - упростить аппаратуру;
    - выжать максимум из процессора (максимально тонкое управление).
1. Убрать проблемы дизайна ISA.
1. Сделать невозможной бинарную совместимость процессоров.
1. Применяется для ускорителей и в области высокоуровневого синтеза (HLS).
1. Низкая плотность машинного кода.
1. Приходите в [NITTA](https://ryukzak.github.io/projects/nitta/) -- параллельный NISC процессор.
